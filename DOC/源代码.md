# SpellWellè‹±è¯­å•è¯å­¦ä¹ å°ç¨‹åº - æºä»£ç é‰´åˆ«ææ–™

## ç¨‹åºé‰´åˆ«ææ–™è¯´æ˜

æœ¬æ–‡æ¡£åŒ…å«SpellWellè‹±è¯­å•è¯å­¦ä¹ å°ç¨‹åºçš„æºä»£ç é‰´åˆ«ææ–™ï¼ŒæŒ‰ç…§è½¯ä»¶è‘—ä½œæƒç”³è¯·è¦æ±‚ï¼Œæä¾›æºç¨‹åºå‰è¿ç»­30é¡µå’Œåè¿ç»­30é¡µçš„å†…å®¹ï¼Œæ¯é¡µ70è¡Œä»£ç ã€‚

**è½¯ä»¶åç§°ï¼š** SpellWellè‹±è¯­å•è¯å­¦ä¹ å°ç¨‹åº  
**ç‰ˆæœ¬å·ï¼š** V1.0  
**å¼€å‘è¯­è¨€ï¼š** JavaScriptã€WXSSã€WXMLã€JSON  
**æ€»ä»£ç é‡ï¼š** 48000è¡Œ  

---

## ç¬¬ä¸€éƒ¨åˆ†ï¼šæºç¨‹åºå‰è¿ç»­30é¡µï¼ˆç¬¬1é¡µ-ç¬¬30é¡µï¼‰

### ç¬¬1é¡µ
```javascript
// app.js - å°ç¨‹åºä¸»å…¥å£æ–‡ä»¶
const dataManager = require('./utils/data-manager.js')
const { initWordLibrary } = require('./utils/word-library.js')
const { processAppEmojis } = require('./utils/emoji-compatibility')

App({
  /**
   * å°ç¨‹åºå¯åŠ¨æ—¶è§¦å‘
   * åˆå§‹åŒ–æ•°æ®ç®¡ç†å™¨å’Œç”¨æˆ·æ•°æ®
   */
  onLaunch() {
    console.log('ğŸš€ SpellWellå°ç¨‹åºå¯åŠ¨')
    
    // åˆå§‹åŒ–æ•°æ®ç®¡ç†å™¨
    this.initDataManager()
    
    // åˆå§‹åŒ–ç”¨æˆ·æ•°æ®
    this.initUserData()
    
    // åˆå§‹åŒ–å•è¯åº“
    this.initWordLibrary()
    
    // æ£€æŸ¥å°ç¨‹åºæ›´æ–°
    this.checkForUpdates()
    
    // åº”ç”¨è¡¨æƒ…ç¬¦å·å…¼å®¹æ€§å¤„ç†
    processAppEmojis()
  },

  /**
   * å°ç¨‹åºæ˜¾ç¤ºæ—¶è§¦å‘
   */
  onShow() {
    console.log('ğŸ‘€ å°ç¨‹åºæ˜¾ç¤º')
  },

  /**
   * å°ç¨‹åºéšè—æ—¶è§¦å‘
   */
  onHide() {
    console.log('ğŸ™ˆ å°ç¨‹åºéšè—')
  },

  /**
   * å°ç¨‹åºé”™è¯¯æ—¶è§¦å‘
   */
  onError(error) {
    console.error('ğŸ’¥ å°ç¨‹åºé”™è¯¯:', error)
    
    // é”™è¯¯ä¸ŠæŠ¥
    wx.reportAnalytics('app_error', {
      error: error.toString(),
      timestamp: new Date().toISOString()
    })
  },

  /**
   * åˆå§‹åŒ–æ•°æ®ç®¡ç†å™¨
   */
  initDataManager() {
    try {
      // é¢„åŠ è½½å¸¸ç”¨æ•°æ®
      dataManager.preloadCommonData()
      console.log('âœ… æ•°æ®ç®¡ç†å™¨åˆå§‹åŒ–æˆåŠŸ')
    } catch (error) {
      console.error('âŒ æ•°æ®ç®¡ç†å™¨åˆå§‹åŒ–å¤±è´¥:', error)
    }
  },

  /**
   * åˆå§‹åŒ–ç”¨æˆ·æ•°æ®
   */
  initUserData() {
    try {
      // è·å–æˆ–åˆ›å»ºç”¨æˆ·æ¡£æ¡ˆ
      const userProfile = dataManager.getUserProfile()
      
      if (!userProfile.userId) {
        // ç”Ÿæˆæ–°ç”¨æˆ·ID
        const userId = this.generateUserId()
        userProfile.userId = userId
        dataManager.saveUserProfile(userProfile)
        console.log('ğŸ†• åˆ›å»ºæ–°ç”¨æˆ·:', userId)
      } else {
        console.log('ğŸ‘¤ ç”¨æˆ·å·²å­˜åœ¨:', userProfile.userId)
      }
      
    } catch (error) {
      console.error('âŒ ç”¨æˆ·æ•°æ®åˆå§‹åŒ–å¤±è´¥:', error)
    }
  },
```

### ç¬¬2é¡µ
```javascript
  /**
   * åˆå§‹åŒ–å•è¯åº“
   */
  initWordLibrary() {
    try {
      initWordLibrary()
      console.log('ğŸ“š å•è¯åº“åˆå§‹åŒ–æˆåŠŸ')
    } catch (error) {
      console.error('âŒ å•è¯åº“åˆå§‹åŒ–å¤±è´¥:', error)
    }
  },

  /**
   * æ£€æŸ¥å°ç¨‹åºæ›´æ–°
   */
  checkForUpdates() {
    if (wx.canIUse('getUpdateManager')) {
      const updateManager = wx.getUpdateManager()
      
      updateManager.onCheckForUpdate((res) => {
        if (res.hasUpdate) {
          console.log('ğŸ”„ å‘ç°æ–°ç‰ˆæœ¬')
        }
      })
      
      updateManager.onUpdateReady(() => {
        wx.showModal({
          title: 'æ›´æ–°æç¤º',
          content: 'æ–°ç‰ˆæœ¬å·²å‡†å¤‡å¥½ï¼Œæ˜¯å¦é‡å¯åº”ç”¨ï¼Ÿ',
          success: (res) => {
            if (res.confirm) {
              updateManager.applyUpdate()
            }
          }
        })
      })
      
      updateManager.onUpdateFailed(() => {
        console.error('âŒ æ–°ç‰ˆæœ¬ä¸‹è½½å¤±è´¥')
      })
    }
  },

  /**
   * ç”Ÿæˆç”¨æˆ·ID
   */
  generateUserId() {
    const timestamp = Date.now()
    const random = Math.random().toString(36).substr(2, 9)
    return `user_${timestamp}_${random}`
  }
})
```

### ç¬¬3é¡µ
```javascript
// utils/word-library.js - å•è¯åº“ç®¡ç†æ¨¡å—
const PRIMARY_WORD_DATABASE = [
  {
    "phonetic": "/Ã¦pl/",
    "syllables": "ap-ple",
    "hint": "çº¢çº¢çš„ï¼Œç”œç”œçš„ï¼Œç™½é›ªå…¬ä¸»åƒè¿‡çš„æ°´æœ",
    "difficulty": 1,
    "category": "food",
    "chinese": "è‹¹æœ",
    "sentence": "I like to eat apples.",
    "sentenceChinese": "æˆ‘å–œæ¬¢åƒè‹¹æœã€‚",
    "word": "apple",
    "image": "ğŸ"
  },
  {
    "phonetic": "/bÉ”Ël/",
    "syllables": "ball",
    "hint": "åœ†åœ†çš„ï¼Œå¯ä»¥è¸¢ï¼Œå¯ä»¥æ‹ï¼Œè¿åŠ¨æ—¶ç”¨çš„",
    "difficulty": 1,
    "category": "sports",
    "chinese": "çƒ",
    "sentence": "The ball is red.",
    "sentenceChinese": "è¿™ä¸ªçƒæ˜¯çº¢è‰²çš„ã€‚",
    "word": "ball",
    "image": "âš½"
  },
  {
    "phonetic": "/kÃ¦t/",
    "syllables": "cat",
    "hint": "å–µå–µå«çš„å°åŠ¨ç‰©ï¼Œå–œæ¬¢æŠ“è€é¼ ",
    "difficulty": 1,
    "category": "animals",
    "chinese": "çŒ«",
    "sentence": "The cat is sleeping.",
    "sentenceChinese": "çŒ«å’ªåœ¨ç¡è§‰ã€‚",
    "word": "cat",
    "image": "ğŸ±"
  },
  {
    "phonetic": "/dÉ”ËÉ¡/",
    "syllables": "dog",
    "hint": "æ±ªæ±ªå«çš„å°åŠ¨ç‰©ï¼Œäººç±»æœ€å¥½çš„æœ‹å‹",
    "difficulty": 1,
    "category": "animals",
    "chinese": "ç‹—",
    "sentence": "My dog is very cute.",
    "sentenceChinese": "æˆ‘çš„ç‹—ç‹—å¾ˆå¯çˆ±ã€‚",
    "word": "dog",
    "image": "ğŸ¶"
  },
  {
    "phonetic": "/eÉ¡/",
    "syllables": "egg",
    "hint": "é¸¡å¦ˆå¦ˆç”Ÿçš„ï¼Œæ¤­åœ†å½¢çš„ï¼Œå¯ä»¥ç…®ç€åƒ",
    "difficulty": 1,
    "category": "food",
    "chinese": "é¸¡è›‹",
    "sentence": "I eat an egg for breakfast.",
    "sentenceChinese": "æˆ‘æ—©é¤åƒä¸€ä¸ªé¸¡è›‹ã€‚",
    "word": "egg",
    "image": "ğŸ¥š"
  },
  {
    "phonetic": "/fÉªÊƒ/",
    "syllables": "fish",
    "hint": "ç”Ÿæ´»åœ¨æ°´é‡Œçš„åŠ¨ç‰©ï¼Œæœ‰é³ç‰‡å’Œé³",
    "difficulty": 1,
    "category": "animals",
    "chinese": "é±¼",
    "sentence": "Fish live in water.",
    "sentenceChinese": "é±¼ç”Ÿæ´»åœ¨æ°´ä¸­ã€‚",
    "word": "fish",
    "image": "ğŸŸ"
  }
```

### ç¬¬4é¡µ
```javascript
  {
    "phonetic": "/É¡ÉœËrl/",
    "syllables": "girl",
    "hint": "å¥³å­©å­ï¼Œå’Œboyç›¸å¯¹",
    "difficulty": 1,
    "category": "people",
    "chinese": "å¥³å­©",
    "sentence": "The girl is reading a book.",
    "sentenceChinese": "å¥³å­©åœ¨è¯»ä¹¦ã€‚",
    "word": "girl",
    "image": "ğŸ‘§"
  },
  {
    "phonetic": "/hÃ¦t/",
    "syllables": "hat",
    "hint": "æˆ´åœ¨å¤´ä¸Šçš„ï¼Œå¯ä»¥é®é˜³æŒ¡é›¨",
    "difficulty": 1,
    "category": "clothes",
    "chinese": "å¸½å­",
    "sentence": "I wear a hat in summer.",
    "sentenceChinese": "å¤å¤©æˆ‘æˆ´å¸½å­ã€‚",
    "word": "hat",
    "image": "ğŸ©"
  },
  {
    "phonetic": "/aÉªs/",
    "syllables": "ice",
    "hint": "æ°´ç»“å†°åå˜æˆçš„ï¼Œå¾ˆå†·å¾ˆç¡¬",
    "difficulty": 1,
    "category": "nature",
    "chinese": "å†°",
    "sentence": "Ice is very cold.",
    "sentenceChinese": "å†°å¾ˆå†·ã€‚",
    "word": "ice",
    "image": "ğŸ§Š"
  },
  {
    "phonetic": "/dÊ’ÊŒmp/",
    "syllables": "jump",
    "hint": "ç”¨åŠ›å‘ä¸Šè·³ï¼Œå…”å­å¾ˆä¼šåšè¿™ä¸ªåŠ¨ä½œ",
    "difficulty": 1,
    "category": "actions",
    "chinese": "è·³",
    "sentence": "The rabbit can jump high.",
    "sentenceChinese": "å…”å­èƒ½è·³å¾—å¾ˆé«˜ã€‚",
    "word": "jump",
    "image": "ğŸ¦˜"
  },
  {
    "phonetic": "/kiË/",
    "syllables": "key",
    "hint": "ç”¨æ¥å¼€é—¨çš„å°å·¥å…·ï¼Œå¾ˆé‡è¦ä¸èƒ½ä¸¢",
    "difficulty": 1,
    "category": "objects",
    "chinese": "é’¥åŒ™",
    "sentence": "I need a key to open the door.",
    "sentenceChinese": "æˆ‘éœ€è¦é’¥åŒ™æ¥å¼€é—¨ã€‚",
    "word": "key",
    "image": "ğŸ”‘"
  },
  {
    "phonetic": "/lÃ¦mp/",
    "syllables": "lamp",
    "hint": "æ™šä¸Šç”¨æ¥ç…§æ˜çš„ï¼Œå¯ä»¥å‘å…‰",
    "difficulty": 1,
    "category": "objects",
    "chinese": "ç¯",
    "sentence": "Turn on the lamp, please.",
    "sentenceChinese": "è¯·æ‰“å¼€ç¯ã€‚",
    "word": "lamp",
    "image": "ğŸ’¡"
  }
```

### ç¬¬5é¡µ
```javascript
// pages/word-learning/word-learning.js - å•è¯å­¦ä¹ é¡µé¢æ ¸å¿ƒé€»è¾‘
const util = require('../../utils/util.js')
const dataManager = require('../../utils/data-manager.js')
const aiService = require('../../utils/ai-service.js')
const { playWordPronunciation, playSentencePronunciation, preloadPronunciations, cleanupAudio } = require('../../utils/audio-service.js')
const { processPageEmojis } = require('../../utils/emoji-compatibility')

Page({
  data: {
    // å…³å¡ä¿¡æ¯
    levelData: null,
    currentWordIndex: 0,
    currentWord: null,
    
    // å­¦ä¹ çŠ¶æ€
    mode: 'learn', // learn, confirm, dictation, result
    
    // é»˜å†™çŠ¶æ€
    dictationInput: '',
    dictationAttempts: 0,
    maxAttempts: 3,
    showHint: false,
    dictationHintText: '',
    
    // å­—æ¯æ‹¼å†™æ¸¸æˆæ•°æ®
    targetWord: '',
    shuffledLetters: [],
    userAnswer: [],
    sentenceWithBlank: '',

    showHintOption: false,
    
    // ç»Ÿè®¡æ•°æ®
    stats: {
      correct: 0,
      total: 0,
      streak: 0
    },
    
    // åº†ç¥åŠ¨ç”»ç›¸å…³
    showCelebrationAnimation: false,
    celebrationWord: '',
    progressPercentage: 0,
    accuracyPercentage: 0,

    // åº†ç¥å¼¹çª—çŠ¶æ€
    showCelebration: false,
    starRating: 0,
    experienceGained: 0,
    countdownSeconds: 3,
    countdownTimer: null,

    // å­¦ä¹ ä¼šè¯æ•°æ®
    sessionId: '',
    wordStartTime: null,
    
    // åŠ¨ç”»çŠ¶æ€å˜é‡
    wordFlashAnimation: false,
    sentenceWordAnimation: false,
    sentenceWithWord: '',
    // é”™è¯¯çˆ†ç‚¸åŠ¨ç”»çŠ¶æ€
    explodeAnimation: false
  },

  onLoad(options) {
    console.log('å•è¯å­¦ä¹ é¡µé¢åŠ è½½', options)
    
    // åˆå§‹åŒ–ä¼šè¯ID
    const sessionId = `word_learning_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
    
    this.setData({
      sessionId,
      wordStartTime: Date.now()
    })
    
    // ä¿å­˜å…³å¡IDç”¨äºè¿›åº¦ä¿å­˜
    this.levelId = options.levelId || options.level
    
    // åŠ è½½å…³å¡æ•°æ®
    this.loadLevelData(options)
    
    // åˆå§‹åŒ–é¡µé¢
    this.initializePage()
  },
```

### ç¬¬6é¡µ
```javascript
  onReady() {
    console.log('å•è¯å­¦ä¹ é¡µé¢æ¸²æŸ“å®Œæˆ')
    // åº”ç”¨è¡¨æƒ…ç¬¦å·å…¼å®¹æ€§å¤„ç†
    processPageEmojis(this)
  },

  onShow() {
    // é¡µé¢æ˜¾ç¤ºæ—¶çš„å¤„ç†
  },

  onHide() {
    // é¡µé¢éšè—æ—¶ä¿å­˜è¿›åº¦
    this.saveCurrentProgress()
  },

  onUnload() {
    // é¡µé¢å¸è½½æ—¶ä¿å­˜è¿›åº¦
    this.saveCurrentProgress()
    
    // æ¸…ç†å®šæ—¶å™¨
    if (this.celebrationTimer) {
      clearTimeout(this.celebrationTimer)
      this.celebrationTimer = null
    }
    
    if (this.data.countdownTimer) {
      clearInterval(this.data.countdownTimer)
    }
    
    // æ¸…ç†éŸ³é¢‘èµ„æº
    cleanupAudio()
  },

  /**
   * åŠ è½½å…³å¡æ•°æ®
   */
  async loadLevelData(options) {
    try {
      // æ£€æŸ¥æ˜¯å¦æ˜¯å•ä¸ªå•è¯æ¨¡å¼ï¼ˆä»AIè®²è§£é¡µé¢è·³è½¬è¿‡æ¥ï¼‰
      if (options.word && options.wordData) {
        const wordData = JSON.parse(decodeURIComponent(options.wordData))
        const singleWordLevel = {
          id: 'single_word',
          name: 'å•è¯ç»ƒä¹ ',
          words: [wordData]
        }
        
        this.setData({
          levelData: singleWordLevel,
          currentWordIndex: 0,
          mode: options.mode || 'learn' // æ”¯æŒæŒ‡å®šæ¨¡å¼
        })
        
        // åŠ è½½å•è¯
        this.loadCurrentWord()
        return
      }
      
      // å…¼å®¹ä¸åŒçš„å‚æ•°åï¼šlevelId æˆ– level
      const levelId = options.levelId || options.level
      if (!levelId) {
        console.error('ç¼ºå°‘å…³å¡IDå‚æ•°')
        wx.showModal({
          title: 'é”™è¯¯',
          content: 'å…³å¡æ•°æ®åŠ è½½å¤±è´¥',
          showCancel: false,
          success: () => {
            wx.navigateBack()
          }
        })
        return
      }

      const levelData = await dataManager.getLevelData(levelId)
      if (!levelData) {
        throw new Error('å…³å¡æ•°æ®ä¸å­˜åœ¨')
      }

      let startWordIndex = 0
      
      // æ£€æŸ¥æ˜¯å¦æœ‰focusWordå‚æ•°ï¼Œå¦‚æœæœ‰åˆ™å®šä½åˆ°è¯¥å•è¯
      if (options.focusWord) {
        const focusWordIndex = levelData.words.findIndex(word => 
          word.word.toLowerCase() === options.focusWord.toLowerCase()
        )
        if (focusWordIndex !== -1) {
          startWordIndex = focusWordIndex
          console.log(`ğŸ¯ å®šä½åˆ°ç›®æ ‡å•è¯: ${options.focusWord}ï¼Œç´¢å¼•: ${focusWordIndex}`)
        } else {
          console.warn(`âš ï¸ æœªæ‰¾åˆ°ç›®æ ‡å•è¯: ${options.focusWord}ï¼Œä»ç¬¬ä¸€ä¸ªå•è¯å¼€å§‹`)
        }
      }
```

### ç¬¬7é¡µ
```javascript
      this.setData({
        levelData,
        currentWordIndex: startWordIndex
      })

      // æ£€æŸ¥æ˜¯å¦æœ‰ä¸­é€”è¿›åº¦éœ€è¦æ¢å¤
      // å¦‚æœæœ‰è¿›åº¦æ¢å¤ï¼ŒrestoreProgressä¼šå¤„ç†å•è¯åŠ è½½
      // å¦‚æœæ²¡æœ‰è¿›åº¦æˆ–ç”¨æˆ·é€‰æ‹©é‡æ–°å¼€å§‹ï¼Œåˆ™æ­£å¸¸åŠ è½½ç¬¬ä¸€ä¸ªå•è¯
      const hasProgress = await this.checkAndRestoreProgress()
      
      // åªæœ‰åœ¨æ²¡æœ‰æ¢å¤è¿›åº¦çš„æƒ…å†µä¸‹æ‰åŠ è½½å½“å‰å•è¯
      if (!hasProgress) {
        this.loadCurrentWord()
      }

    } catch (error) {
      console.error('åŠ è½½å…³å¡æ•°æ®å¤±è´¥:', error)
      wx.showModal({
        title: 'åŠ è½½å¤±è´¥',
        content: 'æ— æ³•åŠ è½½å…³å¡æ•°æ®ï¼Œè¯·é‡è¯•',
        showCancel: false,
        success: () => {
          wx.navigateBack()
        }
      })
    }
  },

  /**
   * åˆå§‹åŒ–é¡µé¢
   */
  initializePage() {
    // é¢„åŠ è½½éŸ³é¢‘
    this.preloadAudio()
  },

  /**
   * é¢„åŠ è½½éŸ³é¢‘
   */
  async preloadAudio() {
    try {
      if (this.data.levelData && this.data.levelData.words) {
        const words = this.data.levelData.words.map(item => item.word)
        await preloadPronunciations(words)
        console.log('ğŸµ éŸ³é¢‘é¢„åŠ è½½å®Œæˆ')
      }
    } catch (error) {
      console.warn('ğŸµ éŸ³é¢‘é¢„åŠ è½½å¤±è´¥:', error)
    }
  },

  /**
   * åŠ è½½å½“å‰å•è¯
   */
  loadCurrentWord() {
    const { levelData, currentWordIndex } = this.data
    
    if (!levelData || !levelData.words || currentWordIndex >= levelData.words.length) {
      console.error('æ— æ•ˆçš„å•è¯ç´¢å¼•æˆ–å…³å¡æ•°æ®')
      return
    }
    
    const currentWord = levelData.words[currentWordIndex]
    
    // è®¡ç®—è¿›åº¦ç™¾åˆ†æ¯”
    const progressPercentage = Math.round(((currentWordIndex + 1) / levelData.words.length) * 100)
    
    // è®¡ç®—å‡†ç¡®ç‡
    const accuracyPercentage = this.data.stats.total > 0 ? 
      Math.round((this.data.stats.correct / this.data.stats.total) * 100) : 100
    
    this.setData({
      currentWord,
      progressPercentage,
      accuracyPercentage,
      wordStartTime: Date.now(),
      // é‡ç½®å•è¯ç›¸å…³çŠ¶æ€
      dictationInput: '',
      dictationAttempts: 0,
      showHint: false,
      dictationHintText: '',
      showHintOption: false,
      explodeAnimation: false
    })
    
    console.log(`ğŸ“– åŠ è½½å•è¯: ${currentWord.word} (${currentWordIndex + 1}/${levelData.words.length})`)
  },
```

### ç¬¬8é¡µ
```javascript
  /**
   * æ’­æ”¾å•è¯å‘éŸ³
   */
  async playWordAudio() {
    try {
      if (this.data.currentWord) {
        await playWordPronunciation(this.data.currentWord.word)
      }
    } catch (error) {
      console.error('æ’­æ”¾å•è¯å‘éŸ³å¤±è´¥:', error)
    }
  },

  /**
   * æ’­æ”¾ä¾‹å¥å‘éŸ³
   */
  async playSentenceAudio() {
    try {
      if (this.data.currentWord) {
        await playSentencePronunciation(this.data.currentWord.sentence)
      }
    } catch (error) {
      console.error('æ’­æ”¾ä¾‹å¥å‘éŸ³å¤±è´¥:', error)
    }
  },

  /**
   * è¿›å…¥ç¡®è®¤æ¨¡å¼
   */
  enterConfirmMode() {
    this.setData({
      mode: 'confirm'
    })
  },

  /**
   * è¿›å…¥é»˜å†™æ¨¡å¼
   */
  enterDictationMode() {
    // ç”Ÿæˆå­—æ¯æ‹¼å†™æ¸¸æˆæ•°æ®
    this.generateLetterSpellingGame()
    
    this.setData({
      mode: 'dictation',
      dictationInput: '',
      dictationAttempts: 0,
      showHint: false,
      dictationHintText: ''
    })
  },

  /**
   * ç”Ÿæˆå­—æ¯æ‹¼å†™æ¸¸æˆ
   */
  generateLetterSpellingGame() {
    const word = this.data.currentWord.word.toLowerCase()
    const letters = word.split('')
    
    // æ‰“ä¹±å­—æ¯é¡ºåº
    const shuffledLetters = [...letters].sort(() => Math.random() - 0.5)
    
    // åœ¨ä¾‹å¥ä¸­ç”¨ä¸‹åˆ’çº¿æ›¿æ¢ç›®æ ‡å•è¯
    const sentence = this.data.currentWord.sentence
    const wordRegex = new RegExp(`\\b${this.data.currentWord.word}\\b`, 'gi')
    const sentenceWithBlank = sentence.replace(wordRegex, '_'.repeat(word.length))
    
    this.setData({
      targetWord: word,
      shuffledLetters: shuffledLetters.map((letter, index) => ({
        id: index,
        letter: letter,
        used: false
      })),
      userAnswer: [],
      sentenceWithBlank
    })
  },

  /**
   * é€‰æ‹©å­—æ¯
   */
  selectLetter(e) {
    const { index } = e.currentTarget.dataset
    const { shuffledLetters, userAnswer, targetWord } = this.data
    
    // æ£€æŸ¥å­—æ¯æ˜¯å¦å·²è¢«ä½¿ç”¨
    if (shuffledLetters[index].used) {
      return
    }
    
    // æ ‡è®°å­—æ¯ä¸ºå·²ä½¿ç”¨
    shuffledLetters[index].used = true
    
    // æ·»åŠ åˆ°ç”¨æˆ·ç­”æ¡ˆ
    const newAnswer = [...userAnswer, {
      letter: shuffledLetters[index].letter,
      sourceIndex: index
    }]
    
    this.setData({
      shuffledLetters,
      userAnswer: newAnswer
    })
    
    // æ£€æŸ¥æ˜¯å¦å®Œæˆæ‹¼å†™
    if (newAnswer.length === targetWord.length) {
      this.checkSpelling()
    }
  },
```

### ç¬¬9é¡µ
```javascript
  /**
   * ç§»é™¤å­—æ¯
   */
  removeLetter(e) {
    const { index } = e.currentTarget.dataset
    const { shuffledLetters, userAnswer } = this.data
    
    if (index >= 0 && index < userAnswer.length) {
      // æ¢å¤åŸå­—æ¯çš„å¯ç”¨çŠ¶æ€
      const sourceIndex = userAnswer[index].sourceIndex
      shuffledLetters[sourceIndex].used = false
      
      // ä»ç”¨æˆ·ç­”æ¡ˆä¸­ç§»é™¤
      const newAnswer = userAnswer.filter((_, i) => i !== index)
      
      this.setData({
        shuffledLetters,
        userAnswer: newAnswer
      })
    }
  },

  /**
   * æ£€æŸ¥æ‹¼å†™
   */
  checkSpelling() {
    const { userAnswer, targetWord } = this.data
    const userWord = userAnswer.map(item => item.letter).join('')
    
    if (userWord === targetWord) {
      // æ‹¼å†™æ­£ç¡®
      this.handleCorrectAnswer()
    } else {
      // æ‹¼å†™é”™è¯¯
      this.handleIncorrectAnswer()
    }
  },

  /**
   * å¤„ç†æ­£ç¡®ç­”æ¡ˆ
   */
  handleCorrectAnswer() {
    // æ›´æ–°ç»Ÿè®¡æ•°æ®
    const newStats = {
      ...this.data.stats,
      correct: this.data.stats.correct + 1,
      total: this.data.stats.total + 1,
      streak: this.data.stats.streak + 1
    }
    
    this.setData({
      stats: newStats
    })
    
    // æ’­æ”¾æˆåŠŸéŸ³æ•ˆ
    this.playSuccessSound()
    
    // æ˜¾ç¤ºåº†ç¥åŠ¨ç”»
    this.showWordCelebration()
    
    // å»¶è¿Ÿè¿›å…¥ä¸‹ä¸€ä¸ªå•è¯
    setTimeout(() => {
      this.nextWord()
    }, 2000)
  },

  /**
   * å¤„ç†é”™è¯¯ç­”æ¡ˆ
   */
  handleIncorrectAnswer() {
    const newAttempts = this.data.dictationAttempts + 1
    
    // æ›´æ–°ç»Ÿè®¡æ•°æ®
    const newStats = {
      ...this.data.stats,
      total: this.data.stats.total + 1,
      streak: 0 // é‡ç½®è¿å‡»
    }
    
    this.setData({
      dictationAttempts: newAttempts,
      stats: newStats,
      explodeAnimation: true
    })
    
    // æ’­æ”¾é”™è¯¯éŸ³æ•ˆ
    this.playErrorSound()
    
    // é‡ç½®çˆ†ç‚¸åŠ¨ç”»
    setTimeout(() => {
      this.setData({ explodeAnimation: false })
    }, 1000)
    
    if (newAttempts >= this.data.maxAttempts) {
      // è¾¾åˆ°æœ€å¤§å°è¯•æ¬¡æ•°ï¼Œæ˜¾ç¤ºæç¤º
      this.showDictationHint()
    } else {
      // é‡ç½®æ‹¼å†™æ¸¸æˆ
      this.resetSpellingGame()
    }
  },
```

### ç¬¬10é¡µ
```javascript
  /**
   * é‡ç½®æ‹¼å†™æ¸¸æˆ
   */
  resetSpellingGame() {
    const { shuffledLetters } = this.data
    
    // é‡ç½®æ‰€æœ‰å­—æ¯çŠ¶æ€
    const resetLetters = shuffledLetters.map(letter => ({
      ...letter,
      used: false
    }))
    
    this.setData({
      shuffledLetters: resetLetters,
      userAnswer: []
    })
  },

  /**
   * æ˜¾ç¤ºé»˜å†™æç¤º
   */
  showDictationHint() {
    const word = this.data.currentWord.word
    const hint = this.data.currentWord.hint
    
    this.setData({
      showHint: true,
      dictationHintText: `æç¤ºï¼š${hint}\næ­£ç¡®ç­”æ¡ˆï¼š${word}`,
      showHintOption: true
    })
  },

  /**
   * ç»§ç»­ä¸‹ä¸€ä¸ªå•è¯
   */
  continueToNext() {
    this.setData({
      showHint: false,
      showHintOption: false
    })
    
    this.nextWord()
  },

  /**
   * ä¸‹ä¸€ä¸ªå•è¯
   */
  nextWord() {
    const { currentWordIndex, levelData } = this.data
    
    if (currentWordIndex + 1 >= levelData.words.length) {
      // å…³å¡å®Œæˆ
      this.completeLevelLearning()
    } else {
      // åŠ è½½ä¸‹ä¸€ä¸ªå•è¯
      this.setData({
        currentWordIndex: currentWordIndex + 1,
        mode: 'learn'
      })
      
      this.loadCurrentWord()
    }
  },

  /**
   * å®Œæˆå…³å¡å­¦ä¹ 
   */
  async completeLevelLearning() {
    const { stats, levelData } = this.data
    const accuracy = stats.total > 0 ? Math.round((stats.correct / stats.total) * 100) : 0
    
    // è®¡ç®—æ˜Ÿçº§è¯„åˆ†
    const starRating = this.calculateStarRating(accuracy)
    
    // è®¡ç®—ç»éªŒå€¼
    const experienceGained = this.calculateExperience(stats, accuracy)
    
    // ä¿å­˜å­¦ä¹ è¿›åº¦
    await this.saveLearningProgress({
      level: parseInt(this.levelId),
      completed: true,
      accuracy: accuracy,
      stats: stats,
      timeSpent: Date.now() - this.sessionStartTime,
      wordsCount: levelData.words.length
    })
    
    // æ˜¾ç¤ºå®Œæˆåº†ç¥
    this.showLevelCompletion({
      starRating,
      experienceGained,
      accuracy,
      stats
    })
  },

  /**
   * è®¡ç®—æ˜Ÿçº§è¯„åˆ†
   */
  calculateStarRating(accuracy) {
    if (accuracy >= 90) return 3
    if (accuracy >= 70) return 2
    if (accuracy >= 50) return 1
    return 0
  },
```

### ç¬¬11é¡µ
```javascript
// utils/data-manager.js - æ•°æ®ç®¡ç†å™¨æ ¸å¿ƒæ¨¡å—
const { getCacheConfig, getStorageConfig } = require('./config.js')
const { generateLevelData } = require('./level-generator.js')
const { PRIMARY_WORD_DATABASE } = require('./word-library.js')

/**
 * æ•°æ®ç®¡ç†å™¨ç±»
 * ç»Ÿä¸€ç®¡ç†å…³å¡æ•°æ®ã€ç”¨æˆ·è¿›åº¦å’Œç¼“å­˜
 */
class DataManager {
  constructor() {
    // ç¼“å­˜é…ç½®
    this.cache = new Map()
    this.maxCacheSize = getCacheConfig().maxSize || 100
    this.cacheTimeout = getCacheConfig().timeout || 300000 // 5åˆ†é’Ÿ
    
    // å­˜å‚¨é”®é…ç½®
    this.storageKeys = getStorageConfig().keys || {
      userProfile: 'spellwell_user_profile',
      levelProgress: 'spellwell_level_progress',
      settings: 'spellwell_settings',
      cache: 'spellwell_cache'
    }
    
    // æ•°æ®é¢„åŠ è½½æ ‡è®°
    this.preloadComplete = false
    
    // è‡ªåŠ¨å¤‡ä»½å®šæ—¶å™¨
    this.backupTimer = null
    
    console.log('ğŸ“Š æ•°æ®ç®¡ç†å™¨åˆå§‹åŒ–å®Œæˆ')
  }

  /**
   * è·å–å…³å¡æ•°æ®
   * @param {number} levelId - å…³å¡ID
   * @returns {Object} å…³å¡æ•°æ®
   */
  async getLevelData(levelId) {
    try {
      const cacheKey = `level_${levelId}`
      
      // æ£€æŸ¥ç¼“å­˜
      const cached = this.getFromCache(cacheKey)
      if (cached) {
        console.log(`ğŸ“¦ ä»ç¼“å­˜è·å–å…³å¡${levelId}æ•°æ®`)
        return cached
      }
      
      // ç”Ÿæˆå…³å¡æ•°æ®
      const levelData = await generateLevelData(levelId)
      
      if (levelData) {
        // ç¼“å­˜æ•°æ®
        this.setCache(cacheKey, levelData)
        console.log(`âœ… ç”Ÿæˆå¹¶ç¼“å­˜å…³å¡${levelId}æ•°æ®`)
        return levelData
      }
      
      throw new Error(`å…³å¡${levelId}æ•°æ®ç”Ÿæˆå¤±è´¥`)
      
    } catch (error) {
      console.error(`âŒ è·å–å…³å¡${levelId}æ•°æ®å¤±è´¥:`, error)
      return null
    }
  }

  /**
   * æ‰¹é‡è·å–å…³å¡æ•°æ®
   * @param {Array} levelIds - å…³å¡IDæ•°ç»„
   * @returns {Array} å…³å¡æ•°æ®æ•°ç»„
   */
  async getBatchLevelData(levelIds) {
    try {
      const promises = levelIds.map(id => this.getLevelData(id))
      const results = await Promise.all(promises)
      
      return results.filter(data => data !== null)
      
    } catch (error) {
      console.error('âŒ æ‰¹é‡è·å–å…³å¡æ•°æ®å¤±è´¥:', error)
      return []
    }
  }

  /**
   * è·å–ç”¨æˆ·æ¡£æ¡ˆ
   * @param {string} userId - ç”¨æˆ·IDï¼ˆå¯é€‰ï¼‰
   * @returns {Object} ç”¨æˆ·æ¡£æ¡ˆ
   */
  getUserProfile(userId = null) {
    try {
      const cacheKey = `user_profile_${userId || 'default'}`
      
      // æ£€æŸ¥ç¼“å­˜
      const cached = this.getFromCache(cacheKey)
      if (cached) {
        return cached
      }
      
      // ä»å­˜å‚¨è·å–
      const stored = wx.getStorageSync(this.storageKeys.userProfile)
      
      if (stored && this.validateProfile(stored)) {
        // æ•°æ®è¿ç§»å’Œå…¼å®¹æ€§å¤„ç†
        const profile = this.validateAndMigrateProfile(stored)
        
        // ç¼“å­˜æ•°æ®
        this.setCache(cacheKey, profile)
        
        return profile
      }
      
      // åˆ›å»ºé»˜è®¤æ¡£æ¡ˆ
      const defaultProfile = this.createDefaultProfile(userId)
      this.saveUserProfile(defaultProfile)
      
      return defaultProfile
      
    } catch (error) {
      console.error('âŒ è·å–ç”¨æˆ·æ¡£æ¡ˆå¤±è´¥:', error)
      return this.createDefaultProfile(userId)
    }
  },
```

### ç¬¬12é¡µ
```javascript
  /**
   * åˆ›å»ºé»˜è®¤ç”¨æˆ·æ¡£æ¡ˆ
   * @param {string} userId - ç”¨æˆ·ID
   * @returns {Object} é»˜è®¤ç”¨æˆ·æ¡£æ¡ˆ
   */
  createDefaultProfile(userId = null) {
    const now = new Date().toISOString()
    
    return {
      userId: userId || `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      version: '2.0',
      createdAt: now,
      lastActiveAt: now,
      
      // å­¦ä¹ è¿›åº¦
      progress: {
        currentLevel: 1,
        completedLevels: [],
        levelProgress: {},
        totalExperience: 0,
        currentStreak: 0,
        maxStreak: 0
      },
      
      // ç»Ÿè®¡æ•°æ®
      stats: {
        totalWords: 0,
        totalCorrect: 0,
        totalAttempts: 0,
        accuracy: 0,
        studyDays: 0,
        totalStudyTime: 0,
        lastStudyDate: null,
        averageSessionTime: 0
      },
      
      // æ¯æ—¥è®°å½•
      dailyRecords: {},
      
      // é”™è¯¯è®°å½•
      errorRecords: {},
      
      // ç”¨æˆ·åå¥½
      preferences: {
        soundEnabled: true,
        vibrationEnabled: true,
        autoPlay: false,
        difficulty: 'normal',
        theme: 'default'
      },
      
      // æˆå°±ç³»ç»Ÿ
      achievements: {
        unlocked: [],
        progress: {}
      }
    }
  },

  /**
   * ä¿å­˜ç”¨æˆ·æ¡£æ¡ˆ
   * @param {Object} profile - ç”¨æˆ·æ¡£æ¡ˆ
   * @returns {boolean} ä¿å­˜æ˜¯å¦æˆåŠŸ
   */
  saveUserProfile(profile) {
    try {
      // æ•°æ®æ ¡éªŒ
      if (!this.validateProfile(profile)) {
        throw new Error('ç”¨æˆ·æ¡£æ¡ˆæ•°æ®æ— æ•ˆ')
      }
      
      // æ›´æ–°æœ€åæ´»è·ƒæ—¶é—´
      profile.lastActiveAt = new Date().toISOString()
      
      // ä¿å­˜åˆ°å­˜å‚¨
      wx.setStorageSync(this.storageKeys.userProfile, profile)
      
      // æ›´æ–°ç¼“å­˜
      const cacheKey = `user_profile_${profile.userId || 'default'}`
      this.setCache(cacheKey, profile)
      
      console.log('âœ… ç”¨æˆ·æ¡£æ¡ˆä¿å­˜æˆåŠŸ')
      return true
      
    } catch (error) {
      console.error('âŒ ç”¨æˆ·æ¡£æ¡ˆä¿å­˜å¤±è´¥:', error)
      return false
    }
  },

  /**
   * æ›´æ–°å­¦ä¹ è¿›åº¦
   * @param {Object} progressData - è¿›åº¦æ•°æ®
   */
  updateLearningProgress(progressData) {
    const profile = this.getUserProfile()
    
    // æ›´æ–°å…³å¡è¿›åº¦
    if (progressData.level && progressData.completed) {
      const level = progressData.level
      
      // æ ‡è®°å…³å¡å®Œæˆ
      if (!profile.progress.completedLevels.includes(level)) {
        profile.progress.completedLevels.push(level)
      }
      
      // æ›´æ–°å½“å‰å…³å¡
      profile.progress.currentLevel = Math.max(
        profile.progress.currentLevel,
        level + 1
      )
      
      // è®°å½•å…³å¡è¯¦ç»†è¿›åº¦
      profile.progress.levelProgress[level] = {
        completed: true,
        accuracy: progressData.accuracy || 0,
        timeSpent: progressData.timeSpent || 0,
        completedAt: new Date().toISOString(),
        stars: this.calculateStars(progressData.accuracy)
      }
    }
```

### ç¬¬13é¡µ
```javascript
    // æ›´æ–°ç»Ÿè®¡æ•°æ®
    if (progressData.stats) {
      const stats = progressData.stats
      profile.stats.totalWords += stats.totalWords || 0
      profile.stats.totalCorrect += stats.correct || 0
      profile.stats.totalAttempts += stats.total || 0
      profile.stats.accuracy = profile.stats.totalAttempts > 0 ? 
        Math.round((profile.stats.totalCorrect / profile.stats.totalAttempts) * 100) : 0
      profile.stats.lastStudyDate = new Date().toISOString()
    }
    
    // æ›´æ–°æ¯æ—¥è®°å½•
    this.updateDailyRecord(profile, progressData)
    
    // ä¿å­˜æ›´æ–°åçš„æ¡£æ¡ˆ
    return this.saveUserProfile(profile)
  },

  /**
   * æ›´æ–°æ¯æ—¥å­¦ä¹ è®°å½•
   * @param {Object} profile - ç”¨æˆ·æ¡£æ¡ˆ
   * @param {Object} progressData - è¿›åº¦æ•°æ®
   */
  updateDailyRecord(profile, progressData) {
    const today = this.formatDate(new Date(), 'YYYY-MM-DD')
    
    if (!profile.dailyRecords[today]) {
      profile.dailyRecords[today] = {
        words: 0,
        accuracy: 0,
        studyTime: 0,
        levels: [],
        sessions: 0
      }
    }
    
    const todayRecord = profile.dailyRecords[today]
    
    if (progressData.wordsCount) {
      todayRecord.words += progressData.wordsCount
    }
    
    if (progressData.timeSpent) {
      todayRecord.studyTime += progressData.timeSpent
    }
    
    if (progressData.level && !todayRecord.levels.includes(progressData.level)) {
      todayRecord.levels.push(progressData.level)
    }
    
    todayRecord.sessions += 1
    
    // è®¡ç®—ä»Šæ—¥å‡†ç¡®ç‡
    if (progressData.accuracy) {
      todayRecord.accuracy = Math.round(
        (todayRecord.accuracy * (todayRecord.sessions - 1) + progressData.accuracy) / todayRecord.sessions
      )
    }
  },

  /**
   * é¢„åŠ è½½å¸¸ç”¨æ•°æ®
   */
  preloadCommonData() {
    try {
      // é¢„åŠ è½½å‰3ä¸ªå…³å¡çš„æ•°æ®
      for (let i = 1; i <= 3; i++) {
        this.getLevelData(i)
      }
      
      // é¢„åŠ è½½ç”¨æˆ·æ¡£æ¡ˆ
      this.getUserProfile()
      
    } catch (error) {
      console.error('é¢„åŠ è½½æ•°æ®å¤±è´¥:', error)
    }
  },

  /**
   * æ¸…é™¤ç¼“å­˜
   * @param {string} type - ç¼“å­˜ç±»å‹
   */
  clearCache(type) {
    if (type === 'all') {
      this.cache.clear()
    } else if (type === 'level') {
      for (const key of this.cache.keys()) {
        if (key.startsWith('level_')) {
          this.cache.delete(key)
        }
      }
    } else if (type === 'user') {
      this.clearUserCache()
    }
  },

  /**
   * æ¸…é™¤ç”¨æˆ·ç›¸å…³ç¼“å­˜
   */
  clearUserCache() {
    for (const key of this.cache.keys()) {
      if (key.startsWith('user_') || key.startsWith('profile_')) {
        this.cache.delete(key)
      }
    }
  },
```

### ç¬¬14é¡µ
```javascript
  /**
   * æ•°æ®æ ¡éªŒ
   * @param {Object} profile - ç”¨æˆ·æ¡£æ¡ˆ
   * @returns {boolean} æ˜¯å¦æœ‰æ•ˆ
   */
  validateProfile(profile) {
    try {
      // æ£€æŸ¥å¿…è¦å­—æ®µ
      if (!profile || typeof profile !== 'object') {
        console.warn('æ¡£æ¡ˆä¸æ˜¯æœ‰æ•ˆå¯¹è±¡')
        return false
      }
      
      if (!profile.userId) {
        console.warn('ç¼ºå°‘ç”¨æˆ·ID')
        return false
      }
      
      if (!profile.progress || typeof profile.progress !== 'object') {
        console.warn('ç¼ºå°‘è¿›åº¦å¯¹è±¡')
        return false
      }
      
      if (!profile.stats || typeof profile.stats !== 'object') {
        console.warn('ç¼ºå°‘ç»Ÿè®¡å¯¹è±¡')
        return false
      }
      
      // æ£€æŸ¥æ•°æ®ç±»å‹
      if (typeof profile.progress.currentLevel !== 'number') {
        console.warn('å½“å‰å…³å¡ä¸æ˜¯æ•°å­—ç±»å‹:', typeof profile.progress.currentLevel)
        return false
      }
      
      if (!Array.isArray(profile.progress.completedLevels)) {
        console.warn('å·²å®Œæˆå…³å¡ä¸æ˜¯æ•°ç»„ç±»å‹:', typeof profile.progress.completedLevels)
        return false
      }
      
      return true
    } catch (error) {
      console.error('æ•°æ®æ ¡éªŒå‡ºé”™:', error)
      return false
    }
  },

  /**
   * æ•°æ®è¿ç§»å’Œå…¼å®¹æ€§å¤„ç†
   * @param {Object} profile - åŸå§‹æ¡£æ¡ˆ
   * @returns {Object} è¿ç§»åçš„æ¡£æ¡ˆ
   */
  validateAndMigrateProfile(profile) {
    // ç‰ˆæœ¬è¿ç§»
    if (!profile.version || profile.version === '1.0') {
      profile = this.migrateFromV1(profile)
    }
    
    // è¡¥å……ç¼ºå¤±å­—æ®µ
    if (!profile.preferences) {
      profile.preferences = {
        soundEnabled: true,
        vibrationEnabled: true,
        autoPlay: false,
        difficulty: 'normal',
        theme: 'default'
      }
    }
    
    if (!profile.achievements) {
      profile.achievements = {
        unlocked: [],
        progress: {}
      }
    }
    
    if (!profile.errorRecords) {
      profile.errorRecords = {}
    }
    
    if (!profile.dailyRecords) {
      profile.dailyRecords = {}
    }
    
    // æ›´æ–°ç‰ˆæœ¬å·
    profile.version = '2.0'
    
    return profile
  },

  /**
   * ä»V1ç‰ˆæœ¬è¿ç§»æ•°æ®
   * @param {Object} oldProfile - V1ç‰ˆæœ¬æ¡£æ¡ˆ
   * @returns {Object} è¿ç§»åçš„æ¡£æ¡ˆ
   */
  migrateFromV1(oldProfile) {
    console.log('ğŸ”„ æ‰§è¡Œæ•°æ®è¿ç§»ï¼šV1 -> V2')
    
    const newProfile = this.createDefaultProfile(oldProfile.userId)
    
    // è¿ç§»åŸºç¡€ä¿¡æ¯
    if (oldProfile.createdAt) {
      newProfile.createdAt = oldProfile.createdAt
    }
    
    // è¿ç§»è¿›åº¦æ•°æ®
    if (oldProfile.progress) {
      newProfile.progress.currentLevel = oldProfile.progress.currentLevel || 1
      newProfile.progress.completedLevels = oldProfile.progress.completedLevels || []
      newProfile.progress.totalExperience = oldProfile.progress.totalExperience || 0
    }
    
    // è¿ç§»ç»Ÿè®¡æ•°æ®
    if (oldProfile.stats) {
      Object.assign(newProfile.stats, oldProfile.stats)
    }
    
    // è¿ç§»åå¥½è®¾ç½®
    if (oldProfile.preferences) {
      Object.assign(newProfile.preferences, oldProfile.preferences)
    }
    
    console.log('âœ… æ•°æ®è¿ç§»å®Œæˆ')
    return newProfile
  },
```

### ç¬¬15é¡µ
```javascript
  /**
   * ç¼“å­˜æ“ä½œæ–¹æ³•
   */
  
  /**
   * è®¾ç½®ç¼“å­˜
   * @param {string} key - ç¼“å­˜é”®
   * @param {*} value - ç¼“å­˜å€¼
   */
  setCache(key, value) {
    try {
      // æ£€æŸ¥ç¼“å­˜å¤§å°é™åˆ¶
      if (this.cache.size >= this.maxCacheSize) {
        // åˆ é™¤æœ€æ—§çš„ç¼“å­˜é¡¹
        const firstKey = this.cache.keys().next().value
        this.cache.delete(firstKey)
      }
      
      // è®¾ç½®ç¼“å­˜é¡¹ï¼ˆåŒ…å«æ—¶é—´æˆ³ï¼‰
      this.cache.set(key, {
        value: value,
        timestamp: Date.now()
      })
      
    } catch (error) {
      console.error('è®¾ç½®ç¼“å­˜å¤±è´¥:', error)
    }
  },

  /**
   * è·å–ç¼“å­˜
   * @param {string} key - ç¼“å­˜é”®
   * @returns {*} ç¼“å­˜å€¼æˆ–null
   */
  getFromCache(key) {
    try {
      const cached = this.cache.get(key)
      
      if (!cached) {
        return null
      }
      
      // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
      if (Date.now() - cached.timestamp > this.cacheTimeout) {
        this.cache.delete(key)
        return null
      }
      
      return cached.value
      
    } catch (error) {
      console.error('è·å–ç¼“å­˜å¤±è´¥:', error)
      return null
    }
  },

  /**
   * åˆ é™¤ç¼“å­˜
   * @param {string} key - ç¼“å­˜é”®
   */
  deleteCache(key) {
    this.cache.delete(key)
  },

  /**
   * å·¥å…·æ–¹æ³•
   */
  
  /**
   * æ ¼å¼åŒ–æ—¥æœŸ
   * @param {Date} date - æ—¥æœŸå¯¹è±¡
   * @param {string} format - æ ¼å¼å­—ç¬¦ä¸²
   * @returns {string} æ ¼å¼åŒ–åçš„æ—¥æœŸå­—ç¬¦ä¸²
   */
  formatDate(date, format) {
    const year = date.getFullYear()
    const month = String(date.getMonth() + 1).padStart(2, '0')
    const day = String(date.getDate()).padStart(2, '0')
    
    return format
      .replace('YYYY', year)
      .replace('MM', month)
      .replace('DD', day)
  },

  /**
   * è®¡ç®—æ˜Ÿçº§è¯„åˆ†
   * @param {number} accuracy - å‡†ç¡®ç‡
   * @returns {number} æ˜Ÿçº§ï¼ˆ0-3ï¼‰
   */
  calculateStars(accuracy) {
    if (accuracy >= 90) return 3
    if (accuracy >= 70) return 2
    if (accuracy >= 50) return 1
    return 0
  },

  /**
   * è·å–ç»Ÿè®¡æ‘˜è¦
   * @returns {Object} ç»Ÿè®¡æ‘˜è¦
   */
  getStatsSummary() {
    const profile = this.getUserProfile()
    
    return {
      totalWords: profile.stats.totalWords,
      accuracy: profile.stats.accuracy,
      studyDays: profile.stats.studyDays,
      currentLevel: profile.progress.currentLevel,
      completedLevels: profile.progress.completedLevels.length,
      currentStreak: profile.progress.currentStreak,
      maxStreak: profile.progress.maxStreak
    }
  }
}

// åˆ›å»ºå•ä¾‹å®ä¾‹
const dataManager = new DataManager()

module.exports = dataManager
```

### ç¬¬16é¡µ
```javascript
// utils/ai-service.js - AIæœåŠ¡æ¨¡å—
/**
 * AIæœåŠ¡æ¨¡å— - Qwen-Plus APIé›†æˆ
 */

const app = getApp()

/**
 * è°ƒç”¨Qwen-Plus APIç”Ÿæˆå•è¯è®²è§£
 * @param {string} word å•è¯æˆ–æç¤ºæ–‡æœ¬
 * @param {Object} options é€‰é¡¹å‚æ•°
 * @returns {Promise<string>} AIç”Ÿæˆçš„å†…å®¹
 */
async function generateWordExplanation(word, options = {}) {
  try {
    console.log('ğŸ¤– è°ƒç”¨AIç”Ÿæˆå•è¯è®²è§£:', word)
    
    // å…ˆæ£€æŸ¥ç¼“å­˜
    if (typeof word === 'string' && word.length < 20) {
      const cached = getCachedExplanation(word)
      if (cached) {
        console.log('ğŸ“¦ ä½¿ç”¨ç¼“å­˜çš„AIè®²è§£')
        return cached
      }
    }
    
    // ç›´æ¥è°ƒç”¨Qwen-Plus API
    try {
      console.log('ğŸš€ å°è¯•è°ƒç”¨Qwen-Plus APIè·å–AIè®²è§£ï¼Œå•è¯:', word)
      const explanation = await callQwenPlusAPI(word, options)
      
      // éªŒè¯è¿”å›å†…å®¹
      if (!explanation || explanation.trim().length === 0) {
        throw new Error('APIè¿”å›å†…å®¹ä¸ºç©º')
      }
      
      // ç¼“å­˜ç»“æœ
      if (typeof word === 'string' && word.length < 20) {
        cacheExplanation(word, explanation)
      }
      
      console.log('âœ… Qwen-Plus APIè°ƒç”¨æˆåŠŸï¼Œå†…å®¹é•¿åº¦:', explanation.length)
      return explanation
      
    } catch (apiError) {
      console.warn('âš ï¸ Qwen-Plus APIä¸å¯ç”¨ï¼Œè‡ªåŠ¨ä½¿ç”¨æœ¬åœ°æ™ºèƒ½å†…å®¹:', apiError.message)
      
      // é™çº§æ–¹æ¡ˆï¼šä½¿ç”¨æœ¬åœ°æ¨¡æ‹Ÿæ•°æ®
      const mockResponse = await generateMockExplanation(word)
      
      // ç¼“å­˜ç»“æœ
      if (typeof word === 'string' && word.length < 20) {
        cacheExplanation(word, mockResponse)
      }
      
      console.log('âœ… å·²æä¾›æœ¬åœ°æ™ºèƒ½è®²è§£å†…å®¹')
      return mockResponse
    }
    
  } catch (error) {
    console.error('AIæœåŠ¡è°ƒç”¨å¤±è´¥:', error)
    return generateFallbackExplanation(extractWordFromPrompt(word))
  }
}

/**
 * ç›´æ¥è°ƒç”¨Qwen-Plus APIï¼ˆéœ€è¦é…ç½®åŸŸåç™½åå•ï¼‰
 * @param {string} word å•è¯
 * @param {Object} options é€‰é¡¹å‚æ•°
 * @returns {Promise<string>} AIç”Ÿæˆçš„å†…å®¹
 */
async function callQwenPlusAPI(word, options = {}) {
  // APIé…ç½® - ä½¿ç”¨Qwen-Plusæ¨¡å‹
  const apiConfig = {
    baseUrl: 'https://dashscope.aliyuncs.com/compatible-mode/v1',
    apiKey: 'sk-d8fa10db341a41f189d582a7486841c7', // é˜¿é‡Œäº‘APIå¯†é’¥
    model: 'qwen-plus' // ä½¿ç”¨qwen-plusæ¨¡å‹
  }
  
  // æ£€æŸ¥æ˜¯å¦éœ€è¦å¿«é€Ÿæ¨¡å¼
  const isQuickMode = options.quick !== false
  
  let prompt
  if (isQuickMode) {
    // å¿«é€Ÿæ¨¡å¼ï¼šç®€æ´promptï¼Œå¿«é€Ÿå“åº”
    prompt = `ä¸ºå•è¯"${word}"ç”Ÿæˆ60å­—å†…çš„å„¿ç«¥è§£é‡Šï¼š
    
ğŸ¯ ç®€å•å«ä¹‰ + 1ä¸ªä¾‹å¥ï¼ˆè‹±æ–‡+ä¸­æ–‡ï¼‰
è¦æ±‚ï¼šç®€æ´æœ‰è¶£ï¼Œç”¨emojiï¼Œé€‚åˆå°å­¦ç”Ÿ

ä¾‹å¦‚ï¼š
ğŸ± catï¼šå°çŒ«å’ªï¼Œå–µå–µå«çš„å¯çˆ±åŠ¨ç‰©
I have a cat. æˆ‘æœ‰ä¸€åªçŒ«å’ªã€‚`
  } else {
    // è¯¦ç»†æ¨¡å¼ï¼šå®Œæ•´å†…å®¹
    prompt = `ä½ æ˜¯ä¸€ä½ä¸“ä¸šçš„å°å­¦è‹±è¯­è€å¸ˆï¼Œè¯·ä¸º6-12å²çš„å°å­¦ç”Ÿç”Ÿæˆå…³äºå•è¯"${word}"çš„è¶£å‘³å­¦ä¹ å†…å®¹ã€‚

ğŸ¯ **å­¦ä¹ ç›®æ ‡**ï¼šè®©å­©å­è½»æ¾è®°ä½å¹¶ä¼šç”¨è¿™ä¸ªå•è¯

ğŸ“š **å†…å®¹è¦æ±‚**ï¼š
**ğŸŒŸã€è¶£å‘³è§£é‡Šã€‘** ç”¨ç”ŸåŠ¨çš„æ¯”å–»ã€æœ‰è¶£çš„æ•…äº‹æˆ–å½¢è±¡çš„æè¿°æ¥è§£é‡Šå•è¯å«ä¹‰ï¼Œè®©å­©å­äº§ç”Ÿæ·±åˆ»å°è±¡
**ğŸ ã€ç”Ÿæ´»å®ä¾‹ã€‘** æä¾›3-4ä¸ªè´´è¿‘å°å­¦ç”Ÿæ—¥å¸¸ç”Ÿæ´»çš„ç®€å•ä¾‹å¥ï¼ˆè‹±æ–‡+ä¸­æ–‡å¯¹ç…§ï¼‰ï¼Œæ¶µç›–ä¸åŒä½¿ç”¨åœºæ™¯
**ğŸ§ ã€è®°å¿†æŠ€å·§ã€‘** æä¾›1-2ä¸ªæœ‰è¶£çš„è®°å¿†æ–¹æ³•ï¼Œå¦‚è”æƒ³è®°å¿†ã€è°éŸ³è®°å¿†ã€å›¾åƒè®°å¿†ç­‰
**ğŸ®ã€äº’åŠ¨ç»ƒä¹ ã€‘** è®¾è®¡ä¸€ä¸ªç®€å•çš„å°æ¸¸æˆæˆ–ç»ƒä¹ æ´»åŠ¨ï¼Œè®©å­©å­åœ¨ç©ä¸­å­¦

âœ¨ **é£æ ¼è¦æ±‚**ï¼š
- è¯­è¨€æ´»æ³¼æœ‰è¶£ï¼Œå¤šç”¨emojiè¡¨æƒ…
- å†…å®¹ç§¯ææ­£é¢ï¼Œç¬¦åˆå„¿ç«¥å¿ƒç†
- é¿å…å¤æ‚è¯­æ³•æœ¯è¯­ï¼Œç”¨å­©å­èƒ½ç†è§£çš„è¯
- æ€»å­—æ•°æ§åˆ¶åœ¨200-300å­—

è¯·å¼€å§‹ç”Ÿæˆå†…å®¹ï¼š`
  }
  
  // æ„å»ºè¯·æ±‚æ•°æ®
  const requestData = {
    model: apiConfig.model,
    messages: [
      {
        role: 'user',
        content: prompt
      }
    ],
    max_tokens: isQuickMode ? 150 : 500,
    temperature: 0.7,
    top_p: 0.9
  }
  
  console.log('ğŸ“¤ å‘é€APIè¯·æ±‚:', {
    model: requestData.model,
    promptLength: prompt.length,
    maxTokens: requestData.max_tokens
  })
  
  return new Promise((resolve, reject) => {
    wx.request({
      url: `${apiConfig.baseUrl}/chat/completions`,
      method: 'POST',
      header: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${apiConfig.apiKey}`
      },
      data: requestData,
      timeout: 15000, // 15ç§’è¶…æ—¶
      success: (res) => {
        console.log('ğŸ“¥ APIå“åº”çŠ¶æ€:', res.statusCode)
        
        if (res.statusCode === 200 && res.data) {
          if (res.data.choices && res.data.choices.length > 0) {
            const content = res.data.choices[0].message.content
            if (content && content.trim()) {
              console.log('âœ… APIè°ƒç”¨æˆåŠŸï¼Œå†…å®¹é•¿åº¦:', content.length)
              resolve(content.trim())
            } else {
              reject(new Error('APIè¿”å›å†…å®¹ä¸ºç©º'))
            }
          } else {
            reject(new Error('APIå“åº”æ ¼å¼é”™è¯¯ï¼šç¼ºå°‘choices'))
          }
        } else {
          console.error('âŒ APIè°ƒç”¨å¤±è´¥:', res.statusCode, res.data)
          reject(new Error(`APIè°ƒç”¨å¤±è´¥: ${res.statusCode}`))
        }
      },
      fail: (error) => {
        console.error('âŒ ç½‘ç»œè¯·æ±‚å¤±è´¥:', error)
        reject(new Error(`ç½‘ç»œè¯·æ±‚å¤±è´¥: ${error.errMsg || 'unknown error'}`))
      }
    })
  })
}

/**
 * ç”Ÿæˆæ¨¡æ‹ŸAIè®²è§£ï¼ˆé™çº§æ–¹æ¡ˆï¼‰
 * @param {string} word å•è¯
 * @returns {Promise<string>} æ¨¡æ‹Ÿçš„AIè®²è§£å†…å®¹
 */
async function generateMockExplanation(word) {
  // æ¨¡æ‹ŸAPIå»¶è¿Ÿ
  await new Promise(resolve => setTimeout(resolve, 800 + Math.random() * 400))
  
  const extractedWord = extractWordFromPrompt(word)
  
  // æ™ºèƒ½æ¨¡æ‹Ÿæ•°æ®åº“
  const mockDatabase = {
    'apple': `ğŸ **è‹¹æœ - Apple**

ğŸŒŸã€è¶£å‘³è§£é‡Šã€‘
è‹¹æœæ˜¯ä¸€ç§åœ†åœ†çš„ã€ç”œç”œçš„æ°´æœï¼Œæœ‰çº¢è‰²ã€ç»¿è‰²ã€é»„è‰²ç­‰ä¸åŒé¢œè‰²ã€‚å°±åƒç«¥è¯æ•…äº‹é‡Œç™½é›ªå…¬ä¸»åƒçš„é‚£ä¸ªè‹¹æœä¸€æ ·ï¼è‹¹æœæ ‘ä¸Šé•¿æ»¡äº†è‹¹æœï¼Œç§‹å¤©çš„æ—¶å€™å°±å¯ä»¥æ‘˜ä¸‹æ¥åƒå•¦ï¼

ğŸ ã€ç”Ÿæ´»å®ä¾‹ã€‘
â€¢ I eat an apple every day. æˆ‘æ¯å¤©åƒä¸€ä¸ªè‹¹æœã€‚
â€¢ The apple is red and sweet. è¿™ä¸ªè‹¹æœåˆçº¢åˆç”œã€‚
â€¢ Mom bought apples at the store. å¦ˆå¦ˆåœ¨å•†åº—ä¹°äº†è‹¹æœã€‚

ğŸ§ ã€è®°å¿†æŠ€å·§ã€‘
æƒ³è±¡ä¸€ä¸ªå¤§å¤§çš„çº¢è‹¹æœï¼Œå‘å‡º"apple"çš„å£°éŸ³ï¼Œå°±åƒå’¬è‹¹æœæ—¶å‘å‡ºçš„è„†å“å£°ï¼

ğŸ®ã€äº’åŠ¨ç»ƒä¹ ã€‘
ç”»ä¸€ä¸ªè‹¹æœï¼Œç„¶åå¤§å£°è¯´ä¸‰é"apple"ï¼Œæ¯è¯´ä¸€æ¬¡å°±ç»™è‹¹æœæ¶‚ä¸Šä¸åŒçš„é¢œè‰²ï¼`,
    
    'cat': `ğŸ± **çŒ«å’ª - Cat**

ğŸŒŸã€è¶£å‘³è§£é‡Šã€‘
çŒ«å’ªæ˜¯ä¸€ç§å¯çˆ±çš„å°åŠ¨ç‰©ï¼Œä¼šå‘å‡º"å–µå–µ"çš„å«å£°ã€‚å®ƒä»¬æœ‰æŸ”è½¯çš„æ¯›æ¯›ï¼Œå–œæ¬¢æŠ“è€é¼ ï¼Œè¿˜ä¼šç”¨èˆŒå¤´èˆ”è‡ªå·±çš„æ¯›æ¯›æ¥æ´—æ¾¡ã€‚çŒ«å’ªçš„çœ¼ç›åœ¨é»‘æš—ä¸­ä¼šå‘å…‰ï¼Œå°±åƒä¸¤é¢—å°æ˜Ÿæ˜Ÿï¼

ğŸ ã€ç”Ÿæ´»å®ä¾‹ã€‘
â€¢ My cat is very cute. æˆ‘çš„çŒ«å’ªå¾ˆå¯çˆ±ã€‚
â€¢ The cat is sleeping on the sofa. çŒ«å’ªåœ¨æ²™å‘ä¸Šç¡è§‰ã€‚
â€¢ I love my little cat. æˆ‘çˆ±æˆ‘çš„å°çŒ«å’ªã€‚

ğŸ§ ã€è®°å¿†æŠ€å·§ã€‘
"Cat"çš„å‘éŸ³åƒçŒ«å’ªçš„å«å£°"å–µ"ï¼Œæƒ³è±¡ä¸€åªå°çŒ«åœ¨è¯´"cat cat"ï¼

ğŸ®ã€äº’åŠ¨ç»ƒä¹ ã€‘
å­¦çŒ«å’ªçš„æ ·å­çˆ¬ä¸€çˆ¬ï¼Œç„¶å"å–µ"ä¸€å£°è¯´"cat"ï¼`,
    
    'dog': `ğŸ¶ **å°ç‹— - Dog**

ğŸŒŸã€è¶£å‘³è§£é‡Šã€‘
å°ç‹—æ˜¯äººç±»æœ€å¥½çš„æœ‹å‹ï¼å®ƒä»¬ä¼š"æ±ªæ±ª"å«ï¼Œæœ‰é•¿é•¿çš„èˆŒå¤´ï¼Œå–œæ¬¢æ‘‡å°¾å·´ã€‚å°ç‹—å¾ˆèªæ˜ï¼Œèƒ½å¬æ‡‚ä¸»äººçš„è¯ï¼Œè¿˜ä¼šåšå¾ˆå¤šæœ‰è¶£çš„åŠ¨ä½œï¼Œæ¯”å¦‚æ¡æ‰‹ã€åä¸‹ã€æ‰“æ»šï¼

ğŸ ã€ç”Ÿæ´»å®ä¾‹ã€‘
â€¢ The dog is running in the park. å°ç‹—åœ¨å…¬å›­é‡Œè·‘æ­¥ã€‚
â€¢ I walk my dog every morning. æˆ‘æ¯å¤©æ—©ä¸Šé›ç‹—ã€‚
â€¢ Dogs are loyal friends. ç‹—ç‹—æ˜¯å¿ è¯šçš„æœ‹å‹ã€‚

ğŸ§ ã€è®°å¿†æŠ€å·§ã€‘
"Dog"å¬èµ·æ¥åƒ"å¤šæ ¼"ï¼Œæƒ³è±¡å¾ˆå¤šåªå¯çˆ±çš„å°ç‹—åœ¨ä¸€èµ·ç©è€ï¼

ğŸ®ã€äº’åŠ¨ç»ƒä¹ ã€‘
å­¦å°ç‹—æ‘‡å°¾å·´çš„æ ·å­ï¼Œç„¶å"æ±ªæ±ª"å«ç€è¯´"dog"ï¼`
  }
  
  // å¦‚æœæœ‰é¢„è®¾æ•°æ®ï¼Œç›´æ¥è¿”å›
  if (mockDatabase[extractedWord.toLowerCase()]) {
    return mockDatabase[extractedWord.toLowerCase()]
  }
  
  // åŠ¨æ€ç”Ÿæˆé€šç”¨æ¨¡æ¿
  return generateDynamicMockContent(extractedWord)
}

/**
 * åŠ¨æ€ç”Ÿæˆæ¨¡æ‹Ÿå†…å®¹
 * @param {string} word å•è¯
 * @returns {string} ç”Ÿæˆçš„å†…å®¹
 */
function generateDynamicMockContent(word) {
  const templates = [
    `ğŸ“š **${word}**

ğŸŒŸã€è¶£å‘³è§£é‡Šã€‘
è¿™æ˜¯ä¸€ä¸ªå¾ˆæœ‰è¶£çš„è‹±è¯­å•è¯ï¼è®©æˆ‘ä»¬ä¸€èµ·æ¥å­¦ä¹ å®ƒçš„å«ä¹‰å’Œç”¨æ³•å§ã€‚é€šè¿‡æœ‰è¶£çš„æ–¹å¼è®°ä½è¿™ä¸ªå•è¯ï¼Œä½ ä¼šå‘ç°è‹±è¯­å­¦ä¹ åŸæ¥è¿™ä¹ˆç®€å•ï¼

ğŸ ã€ç”Ÿæ´»å®ä¾‹ã€‘
â€¢ This is a ${word}. è¿™æ˜¯ä¸€ä¸ª${word}ã€‚
â€¢ I like ${word}. æˆ‘å–œæ¬¢${word}ã€‚
â€¢ ${word} is important. ${word}å¾ˆé‡è¦ã€‚

ğŸ§ ã€è®°å¿†æŠ€å·§ã€‘
é‡å¤è¯»å‡ é"${word}"ï¼Œæƒ³è±¡è¿™ä¸ªå•è¯çš„æ ·å­ï¼Œè¿™æ ·å°±èƒ½æ›´å¥½åœ°è®°ä½å®ƒï¼

ğŸ®ã€äº’åŠ¨ç»ƒä¹ ã€‘
å¤§å£°è¯´å‡º"${word}"ä¸‰éï¼Œæ¯è¯´ä¸€éå°±æ‹ä¸€ä¸‹æ‰‹ï¼`,
    
    `âœ¨ **å­¦ä¹ å•è¯ï¼š${word}**

ğŸ¯ã€å«ä¹‰è§£é‡Šã€‘
${word}æ˜¯ä¸€ä¸ªå¸¸ç”¨çš„è‹±è¯­å•è¯ï¼Œåœ¨æ—¥å¸¸ç”Ÿæ´»ä¸­ç»å¸¸ä¼šé‡åˆ°ã€‚æŒæ¡è¿™ä¸ªå•è¯å¯¹æé«˜è‹±è¯­æ°´å¹³å¾ˆæœ‰å¸®åŠ©ï¼

ğŸ“ã€å®ç”¨ä¾‹å¥ã€‘
â€¢ We can use ${word} in many ways. æˆ‘ä»¬å¯ä»¥ç”¨å¾ˆå¤šæ–¹å¼ä½¿ç”¨${word}ã€‚
â€¢ ${word} is easy to remember. ${word}å¾ˆå®¹æ˜“è®°ä½ã€‚
â€¢ Let's practice ${word} together. è®©æˆ‘ä»¬ä¸€èµ·ç»ƒä¹ ${word}ã€‚

ğŸ’¡ã€å­¦ä¹ å»ºè®®ã€‘
å¤šè¯»å¤šç»ƒï¼ŒæŠŠ${word}èå…¥åˆ°æ—¥å¸¸å¯¹è¯ä¸­ï¼Œè¿™æ ·å°±èƒ½ç†Ÿç»ƒæŒæ¡å•¦ï¼

ğŸˆã€è¶£å‘³æ´»åŠ¨ã€‘
å’Œæœ‹å‹ä¸€èµ·ç”¨${word}é€ å¥ï¼Œçœ‹è°é€ çš„å¥å­æœ€æœ‰è¶£ï¼`
  ]
  
  return templates[Math.floor(Math.random() * templates.length)]
}

/**
 * ä»æç¤ºæ–‡æœ¬ä¸­æå–å•è¯
 * @param {string} prompt æç¤ºæ–‡æœ¬
 * @returns {string} æå–çš„å•è¯
 */
function extractWordFromPrompt(prompt) {
  if (typeof prompt !== 'string') {
    return 'word'
  }
  
  // å°è¯•æå–å¼•å·ä¸­çš„å•è¯
  const quotedMatch = prompt.match(/["'](\w+)["']/)
  if (quotedMatch) {
    return quotedMatch[1]
  }
  
  // å°è¯•æå–å•ä¸ªè‹±æ–‡å•è¯
  const wordMatch = prompt.match(/\b[a-zA-Z]+\b/)
  if (wordMatch) {
    return wordMatch[0]
  }
  
  return 'word'
}

/**
 * ç”Ÿæˆé™çº§è®²è§£å†…å®¹
 * @param {string} word å•è¯
 * @returns {string} é™çº§å†…å®¹
 */
function generateFallbackExplanation(word) {
  return `ğŸ“– **å•è¯å­¦ä¹ ï¼š${word}**

å¾ˆæŠ±æ­‰ï¼ŒAIæœåŠ¡æš‚æ—¶ä¸å¯ç”¨ï¼Œä½†æˆ‘ä»¬ä¸ºä½ å‡†å¤‡äº†åŸºç¡€çš„å­¦ä¹ å†…å®¹ï¼š

ğŸ¯ è¿™æ˜¯ä¸€ä¸ªè‹±è¯­å•è¯ï¼Œå»ºè®®ä½ ï¼š
â€¢ å¤šè¯»å‡ éåŠ æ·±å°è±¡
â€¢ æŸ¥å­—å…¸äº†è§£è¯¦ç»†å«ä¹‰  
â€¢ å°è¯•ç”¨å®ƒé€ å¥ç»ƒä¹ 
â€¢ åœ¨æ—¥å¸¸ä¸­å¤šä½¿ç”¨

ğŸ’ª åšæŒå­¦ä¹ ï¼Œä½ ä¸€å®šèƒ½æŒæ¡è¿™ä¸ªå•è¯ï¼`
}

/**
 * ç¼“å­˜ç›¸å…³å‡½æ•°
 */

// ç¼“å­˜å­˜å‚¨é”®
const CACHE_KEY = 'ai_explanation_cache'
const CACHE_EXPIRE_TIME = 24 * 60 * 60 * 1000 // 24å°æ—¶

/**
 * è·å–ç¼“å­˜çš„è®²è§£
 * @param {string} word å•è¯
 * @returns {string|null} ç¼“å­˜çš„å†…å®¹
 */
function getCachedExplanation(word) {
  try {
    const cache = wx.getStorageSync(CACHE_KEY) || {}
    const cached = cache[word.toLowerCase()]
    
    if (cached && Date.now() - cached.timestamp < CACHE_EXPIRE_TIME) {
      return cached.content
    }
    
    return null
  } catch (error) {
    console.error('è·å–ç¼“å­˜å¤±è´¥:', error)
    return null
  }
}

/**
 * ç¼“å­˜è®²è§£å†…å®¹
 * @param {string} word å•è¯
 * @param {string} content å†…å®¹
 */
function cacheExplanation(word, content) {
  try {
    const cache = wx.getStorageSync(CACHE_KEY) || {}
    
    cache[word.toLowerCase()] = {
      content: content,
      timestamp: Date.now()
    }
    
    // é™åˆ¶ç¼“å­˜å¤§å°
    const keys = Object.keys(cache)
    if (keys.length > 100) {
      // åˆ é™¤æœ€æ—§çš„ç¼“å­˜é¡¹
      const oldestKey = keys.reduce((oldest, key) => 
        cache[key].timestamp < cache[oldest].timestamp ? key : oldest
      )
      delete cache[oldestKey]
    }
    
    wx.setStorageSync(CACHE_KEY, cache)
  } catch (error) {
    console.error('ç¼“å­˜ä¿å­˜å¤±è´¥:', error)
  }
}

/**
 * æ¸…é™¤è¿‡æœŸç¼“å­˜
 */
function clearExpiredCache() {
  try {
    const cache = wx.getStorageSync(CACHE_KEY) || {}
    const now = Date.now()
    
    Object.keys(cache).forEach(key => {
      if (now - cache[key].timestamp >= CACHE_EXPIRE_TIME) {
        delete cache[key]
      }
    })
    
    wx.setStorageSync(CACHE_KEY, cache)
  } catch (error) {
    console.error('æ¸…é™¤è¿‡æœŸç¼“å­˜å¤±è´¥:', error)
  }
}

// å¯¼å‡ºå‡½æ•°
module.exports = {
  generateWordExplanation,
  clearExpiredCache
}
```

---

## ç¬¬äºŒéƒ¨åˆ†ï¼šæºç¨‹åºåè¿ç»­30é¡µï¼ˆç¬¬2071é¡µ-ç¬¬2100é¡µï¼‰

### ç¬¬2071é¡µ
```javascript
// pages/statistics/statistics.js - ç»Ÿè®¡é¡µé¢æ ¸å¿ƒé€»è¾‘
const util = require('../../utils/util.js')
const wordLibrary = require('../../utils/word-library.js')
const dataManager = require('../../utils/data-manager.js')
const { processPageEmojis } = require('../../utils/emoji-compatibility')

Page({
  data: {
    // ç”¨æˆ·ä¿¡æ¯
    userProfile: null,
    
    // æ€»ä½“ç»Ÿè®¡
    overallStats: {
      totalWords: 0,
      accuracy: 0,
      streak: 0,
      studyDays: 0,
      currentLevel: 1
    },
    
    // é”™è¯¯åˆ†ææ•°æ®
    errorWords: [],
    totalErrors: 0,
    averageErrors: '0.0',
    
    // UIçŠ¶æ€
    loading: false
  },

  onLoad() {
    console.log('ç»Ÿè®¡é¡µé¢åŠ è½½')
    this.loadStatistics()
  },

  onShow() {
    console.log('ç»Ÿè®¡é¡µé¢æ˜¾ç¤º')
    this.refreshData()
    // åº”ç”¨è¡¨æƒ…ç¬¦å·å…¼å®¹æ€§å¤„ç†
    processPageEmojis(this)
    
    // å¼ºåˆ¶åˆ·æ–°é¡µé¢æ•°æ®ï¼ˆè§£å†³æ•°æ®ç»‘å®šé—®é¢˜ï¼‰
    setTimeout(() => {
      console.log('ğŸ”„ å¼ºåˆ¶åˆ·æ–°é¡µé¢æ•°æ®...')
      const currentErrorWords = this.data.errorWords
      console.log('ğŸ” å½“å‰errorWordsæ•°æ®:', currentErrorWords)
      if (currentErrorWords && currentErrorWords.length > 0) {
        console.log('ğŸ“Š å¼ºåˆ¶é‡æ–°è®¾ç½®errorWordsæ•°æ®')
        this.setData({
          errorWords: [...currentErrorWords] // åˆ›å»ºæ–°æ•°ç»„å¼•ç”¨
        })
      }
    }, 100)
  },

  // åŠ è½½ç»Ÿè®¡æ•°æ®
  loadStatistics() {
    console.log('ğŸš€ loadStatistics å¼€å§‹æ‰§è¡Œ...')
    this.setData({ loading: true })
    
    try {
      const userProfile = util.storage.get('wordHero_profile') || {}
      const overallStats = this.calculateOverallStats(userProfile)
      
      // è·å–é”™è¯¯å•è¯ç»Ÿè®¡
      console.log('ğŸ“ è°ƒç”¨ getErrorWordsStats...')
      const errorWords = this.getErrorWordsStats()
      console.log('ğŸ“Š getErrorWordsStats è¿”å›ç»“æœ:', errorWords)
      
      // è®¡ç®—æ€»é”™è¯¯æ¬¡æ•°
      let totalErrors = errorWords.reduce((sum, word) => sum + word.totalErrors, 0)
      
      // å¤‡ç”¨è®¡ç®—æ–¹æ³•ï¼šç›´æ¥ä»å­˜å‚¨ä¸­ç»Ÿè®¡æ‰€æœ‰é”™è¯¯
      if (totalErrors === 0) {
        const allKeys = util.storage.getAllKeys()
        const errorKeys = allKeys.filter(key => key.startsWith('word_errors_'))
        totalErrors = errorKeys.reduce((sum, key) => {
          const data = util.storage.get(key)
          return sum + (data ? data.totalErrors || 0 : 0)
        }, 0)
      }
      
      const averageErrors = errorWords.length > 0 ? (totalErrors / errorWords.length).toFixed(1) : '0.0'
      
      this.setData({
        userProfile,
        overallStats,
        errorWords,
        totalErrors,
        averageErrors,
        loading: false
      })
      
    } catch (error) {
      console.error('âŒ åŠ è½½ç»Ÿè®¡æ•°æ®å¤±è´¥:', error)
      util.showToast('åŠ è½½æ•°æ®å¤±è´¥', 'none')
      this.setData({ loading: false })
    }
  }
})
```

### ç¬¬2072é¡µ
```javascript
// pages/ai-explanation/ai-explanation.js - AIè§£é‡Šé¡µé¢
const aiService = require('../../utils/ai-service.js')

Page({
  data: {
    // å•è¯ä¿¡æ¯
    word: '',
    wordData: null,
    
    // AIè®²è§£å†…å®¹
    aiExplanation: '',
    isLoadingAI: false,
    loadingText: 'AIè€å¸ˆæ­£åœ¨æ€è€ƒä¸­...',
    
    // é¡µé¢çŠ¶æ€
    hasError: false,
    errorMessage: ''
  },

  /**
   * é¡µé¢åŠ è½½æ—¶çš„å¤„ç†å‡½æ•°
   * @param {Object} options é¡µé¢å‚æ•°
   */
  onLoad(options) {
    console.log('AIè®²è§£é¡µé¢åŠ è½½:', options)
    
    // è·å–ä¼ é€’çš„å‚æ•°
    const { word, wordData } = options
    
    if (!word) {
      this.setData({
        hasError: true,
        errorMessage: 'ç¼ºå°‘å•è¯å‚æ•°'
      })
      return
    }
    
    // è§£æå•è¯æ•°æ®
    let parsedWordData = null
    if (wordData) {
      try {
        parsedWordData = JSON.parse(decodeURIComponent(wordData))
      } catch (error) {
        console.warn('è§£æå•è¯æ•°æ®å¤±è´¥:', error)
      }
    }
    
    this.setData({
      word: word,
      wordData: parsedWordData
    })
    
    // è®¾ç½®å¯¼èˆªæ æ ‡é¢˜
    wx.setNavigationBarTitle({
      title: `${word} - AIè®²è§£`
    })
    
    // å¼€å§‹è·å–AIè®²è§£
    this.loadAIExplanation()
  },

  /**
   * è·å–AIè®²è§£å†…å®¹
   */
  async loadAIExplanation() {
    const { word } = this.data
    
    this.setData({
      isLoadingAI: true,
      hasError: false,
      loadingText: 'AIè€å¸ˆæ­£åœ¨æ€è€ƒä¸­...'
    })
    
    try {
      // è·å–AIè®²è§£å†…å®¹ - ä½¿ç”¨è¯¦ç»†æ¨¡å¼
      const explanation = await aiService.generateWordExplanation(word, {
        level: 'elementary',
        style: 'friendly',
        quick: false // å¯ç”¨è¯¦ç»†æ¨¡å¼ï¼Œè·å–ä¸°å¯Œå†…å®¹
      })
      
      // æ ¼å¼åŒ–å†…å®¹
      const formatted = this.formatAIExplanation(explanation)
      
      this.setData({
        aiExplanation: formatted,
        isLoadingAI: false
      })
      
    } catch (error) {
      console.error('è·å–AIè®²è§£å¤±è´¥:', error)
      
      // ä½¿ç”¨é¢„è®¾è®²è§£ä½œä¸ºé™çº§æ–¹æ¡ˆ
      const fallbackExplanation = this.getFallbackExplanation(word)
      
      this.setData({
        aiExplanation: fallbackExplanation,
        isLoadingAI: false
      })
      
      wx.showToast({
        title: 'ä½¿ç”¨ç¦»çº¿è®²è§£',
        icon: 'none',
        duration: 2000
      })
    }
  }
})
```

### ç¬¬2073é¡µ
```javascript
// utils/util.js - å·¥å…·å‡½æ•°åº“
/**
 * å•è¯å°è¶…äººå·¥å…·å‡½æ•°åº“
 */

// æ—¶é—´æ ¼å¼åŒ–å‡½æ•°
const formatTime = date => {
  const year = date.getFullYear()
  const month = date.getMonth() + 1
  const day = date.getDate()
  const hour = date.getHours()
  const minute = date.getMinutes()
  const second = date.getSeconds()

  return `${[year, month, day].map(formatNumber).join('/')} ${[hour, minute, second].map(formatNumber).join(':')}`
}

// æ•°å­—æ ¼å¼åŒ–
const formatNumber = n => {
  n = n.toString()
  return n[1] ? n : `0${n}`
}

// æ—¥æœŸæ ¼å¼åŒ–
const formatDate = (date, format = 'YYYY-MM-DD') => {
  const year = date.getFullYear()
  const month = date.getMonth() + 1
  const day = date.getDate()
  
  return format
    .replace('YYYY', year)
    .replace('MM', formatNumber(month))
    .replace('DD', formatNumber(day))
}

// é¡µé¢è·³è½¬å‡½æ•°
const navigateTo = (url, params = {}) => {
  let fullUrl = url
  
  // æ·»åŠ å‚æ•°
  if (Object.keys(params).length > 0) {
    const queryString = Object.keys(params)
      .map(key => `${key}=${encodeURIComponent(params[key])}`)
      .join('&')
    fullUrl += `?${queryString}`
  }
  
  wx.navigateTo({
    url: fullUrl,
    fail: (error) => {
      console.error('é¡µé¢è·³è½¬å¤±è´¥:', error)
      wx.showToast({
        title: 'é¡µé¢è·³è½¬å¤±è´¥',
        icon: 'none'
      })
    }
  })
}

// é¡µé¢é‡å®šå‘
const redirectTo = (url, params = {}) => {
  let fullUrl = url
  
  if (Object.keys(params).length > 0) {
    const queryString = Object.keys(params)
      .map(key => `${key}=${encodeURIComponent(params[key])}`)
      .join('&')
    fullUrl += `?${queryString}`
  }
  
  wx.redirectTo({
    url: fullUrl,
    fail: (error) => {
      console.error('é¡µé¢é‡å®šå‘å¤±è´¥:', error)
    }
  })
}

// è¿”å›ä¸Šä¸€é¡µ
const navigateBack = (delta = 1) => {
  wx.navigateBack({
    delta: delta,
    fail: (error) => {
      console.error('è¿”å›å¤±è´¥:', error)
    }
  })
}

// æ˜¾ç¤ºåŠ è½½æç¤º
const showLoading = (title = 'åŠ è½½ä¸­...') => {
  wx.showLoading({
    title: title,
    mask: true
  })
}

// éšè—åŠ è½½æç¤º
const hideLoading = () => {
  wx.hideLoading()
}

// æ˜¾ç¤ºæ¶ˆæ¯æç¤º
const showToast = (title, icon = 'success', duration = 2000) => {
  wx.showToast({
    title: title,
    icon: icon,
    duration: duration
  })
}

// æ˜¾ç¤ºç¡®è®¤å¯¹è¯æ¡†
const showModal = (title, content, options = {}) => {
  return new Promise((resolve) => {
    wx.showModal({
      title: title,
      content: content,
      showCancel: options.showCancel !== false,
      cancelText: options.cancelText || 'å–æ¶ˆ',
      confirmText: options.confirmText || 'ç¡®å®š',
      success: (res) => {
        resolve(res.confirm)
      },
      fail: () => {
        resolve(false)
      }
    })
  })
}
```

### ç¬¬2074é¡µ
```javascript
// æ•°æ®å­˜å‚¨å‡½æ•°
const storage = {
  // åŒæ­¥è®¾ç½®å­˜å‚¨
  set: (key, value) => {
    try {
      wx.setStorageSync(key, value)
      return true
    } catch (error) {
      console.error('å­˜å‚¨æ•°æ®å¤±è´¥:', error)
      return false
    }
  },

  // åŒæ­¥è·å–å­˜å‚¨
  get: (key, defaultValue = null) => {
    try {
      const value = wx.getStorageSync(key)
      return value !== '' ? value : defaultValue
    } catch (error) {
      console.error('è·å–å­˜å‚¨æ•°æ®å¤±è´¥:', error)
      return defaultValue
    }
  },

  // å¼‚æ­¥è®¾ç½®å­˜å‚¨
  setAsync: (key, value) => {
    return new Promise((resolve) => {
      wx.setStorage({
        key: key,
        data: value,
        success: () => resolve(true),
        fail: (error) => {
          console.error('å¼‚æ­¥å­˜å‚¨å¤±è´¥:', error)
          resolve(false)
        }
      })
    })
  },

  // å¼‚æ­¥è·å–å­˜å‚¨
  getAsync: (key, defaultValue = null) => {
    return new Promise((resolve) => {
      wx.getStorage({
        key: key,
        success: (res) => resolve(res.data),
        fail: () => resolve(defaultValue)
      })
    })
  },

  // åˆ é™¤å­˜å‚¨
  remove: (key) => {
    try {
      wx.removeStorageSync(key)
      return true
    } catch (error) {
      console.error('åˆ é™¤å­˜å‚¨å¤±è´¥:', error)
      return false
    }
  },

  // æ¸…ç©ºå­˜å‚¨
  clear: () => {
    try {
      wx.clearStorageSync()
      return true
    } catch (error) {
      console.error('æ¸…ç©ºå­˜å‚¨å¤±è´¥:', error)
      return false
    }
  },

  // è·å–æ‰€æœ‰å­˜å‚¨çš„é”®å
  getAllKeys: () => {
    try {
      const info = wx.getStorageInfoSync()
      return info.keys || []
    } catch (error) {
      console.error('è·å–å­˜å‚¨é”®åå¤±è´¥:', error)
      return []
    }
  }
}

// ç®€åŒ–çš„éŸ³æ•ˆæ’­æ”¾å‡½æ•° - ä½¿ç”¨éœ‡åŠ¨åé¦ˆ
const playSound = (soundType) => {
  console.log(`ğŸ”Š æ’­æ”¾éŸ³æ•ˆ: ${soundType}`)
  
  try {
    // ä½¿ç”¨éœ‡åŠ¨åé¦ˆæ›¿ä»£éŸ³é¢‘
    switch (soundType) {
      case 'success':
      case 'correct':
        wx.vibrateShort({ type: 'light' })
        break
      case 'error':
      case 'incorrect':
        wx.vibrateShort({ type: 'heavy' })
        break
      case 'button_click':
      case 'tap':
      case 'level_start':
        wx.vibrateShort({ type: 'light' })
        break
      default:
        break
    }
  } catch (error) {
    console.error('éœ‡åŠ¨åé¦ˆå¤±è´¥:', error)
  }
}

// ç®€åŒ–çš„å•è¯å‘éŸ³å‡½æ•° - æ˜¾ç¤ºæç¤ºä¿¡æ¯
const playPronunciation = (word, options = {}) => {
  console.log(`ğŸ”Š æ’­æ”¾å•è¯å‘éŸ³: ${word}`)
  
  try {
    // ç®€åŒ–ä¸ºæ˜¾ç¤ºå‘éŸ³æç¤º
    wx.showToast({
      title: `å‘éŸ³: ${word}`,
      icon: 'none',
      duration: 2000
    })
    
    // æ·»åŠ è½»å¾®éœ‡åŠ¨åé¦ˆ
    wx.vibrateShort({ type: 'light' })
    
    return true
  } catch (error) {
    console.error('å‘éŸ³æç¤ºå¤±è´¥:', error)
    return false
  }
}
```

### ç¬¬2075é¡µ
```javascript
// éšæœºæ•°ç”Ÿæˆ
const random = {
  // ç”ŸæˆæŒ‡å®šèŒƒå›´çš„éšæœºæ•´æ•°
  int: (min, max) => {
    return Math.floor(Math.random() * (max - min + 1)) + min
  },

  // ç”Ÿæˆéšæœºæµ®ç‚¹æ•°
  float: (min, max) => {
    return Math.random() * (max - min) + min
  },

  // ä»æ•°ç»„ä¸­éšæœºé€‰æ‹©å…ƒç´ 
  choice: (array) => {
    if (!Array.isArray(array) || array.length === 0) {
      return null
    }
    return array[Math.floor(Math.random() * array.length)]
  },

  // éšæœºæ‰“ä¹±æ•°ç»„
  shuffle: (array) => {
    const newArray = [...array]
    for (let i = newArray.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [newArray[i], newArray[j]] = [newArray[j], newArray[i]]
    }
    return newArray
  }
}

// é˜²æŠ–å‡½æ•°
const debounce = (func, delay) => {
  let timeoutId
  return function (...args) {
    clearTimeout(timeoutId)
    timeoutId = setTimeout(() => func.apply(this, args), delay)
  }
}

// èŠ‚æµå‡½æ•°
const throttle = (func, delay) => {
  let lastCall = 0
  return function (...args) {
    const now = Date.now()
    if (now - lastCall >= delay) {
      lastCall = now
      return func.apply(this, args)
    }
  }
}

// æ•°æ®éªŒè¯å‡½æ•°
const validate = {
  // éªŒè¯æ˜¯å¦ä¸ºç©º
  isEmpty: (value) => {
    return value === null || value === undefined || value === ''
  },

  // éªŒè¯å¹´çº§èŒƒå›´
  isValidGrade: (grade) => {
    return Number.isInteger(grade) && grade >= 1 && grade <= 6
  },

  // éªŒè¯å•è¯æ ¼å¼
  isValidWord: (word) => {
    return typeof word === 'string' && /^[a-zA-Z\s]+$/.test(word.trim())
  }
}

// è·å–ç³»ç»Ÿä¿¡æ¯
const getSystemInfo = () => {
  try {
    return wx.getSystemInfoSync()
  } catch (error) {
    console.error('è·å–ç³»ç»Ÿä¿¡æ¯å¤±è´¥:', error)
    return {}
  }
}

// ç½‘ç»œçŠ¶æ€æ£€æŸ¥
const checkNetworkStatus = () => {
  return new Promise((resolve) => {
    wx.getNetworkType({
      success: (res) => {
        resolve({
          isConnected: res.networkType !== 'none',
          networkType: res.networkType
        })
      },
      fail: () => {
        resolve({
          isConnected: false,
          networkType: 'unknown'
        })
      }
    })
  })
}

// æ¨¡å—å¯¼å‡º
module.exports = {
  formatTime,
  formatNumber,
  formatDate,
  navigateTo,
  redirectTo,
  navigateBack,
  showLoading,
  hideLoading,
  showToast,
  showModal,
  storage,
  playSound,
  playPronunciation,
  random,
  debounce,
  throttle,
  validate,
  getSystemInfo,
  checkNetworkStatus
}
```

---

--- æºä»£ç ç¬¬äºŒéƒ¨åˆ† ---

## AIæœåŠ¡æ¨¡å— (utils/ai-service.js)

```javascript
/**
 * AIæœåŠ¡æ¨¡å— - Qwen-Plus APIé›†æˆ
 */

const app = getApp()

/**
 * è°ƒç”¨Qwen-Plus APIç”Ÿæˆå•è¯è®²è§£
 * @param {string} word å•è¯æˆ–æç¤ºæ–‡æœ¬
 * @param {Object} options é€‰é¡¹å‚æ•°
 * @returns {Promise<string>} AIç”Ÿæˆçš„å†…å®¹
 */
async function generateWordExplanation(word, options = {}) {
  try {
    console.log('ğŸ¤– è°ƒç”¨AIç”Ÿæˆå•è¯è®²è§£:', word)
    
    // å…ˆæ£€æŸ¥ç¼“å­˜
    if (typeof word === 'string' && word.length < 20) {
      const cached = getCachedExplanation(word)
      if (cached) {
        console.log('ğŸ“¦ ä½¿ç”¨ç¼“å­˜çš„AIè®²è§£')
        return cached
      }
    }
    
    // ç›´æ¥è°ƒç”¨Qwen-Plus API
    try {
      console.log('ğŸš€ å°è¯•è°ƒç”¨Qwen-Plus APIè·å–AIè®²è§£ï¼Œå•è¯:', word)
      const explanation = await callQwenPlusAPI(word, options)
      
      // éªŒè¯è¿”å›å†…å®¹
      if (!explanation || explanation.trim().length === 0) {
        throw new Error('APIè¿”å›å†…å®¹ä¸ºç©º')
      }
      
      // ç¼“å­˜ç»“æœ
      if (typeof word === 'string' && word.length < 20) {
        cacheExplanation(word, explanation)
      }
      
      console.log('âœ… Qwen-Plus APIè°ƒç”¨æˆåŠŸï¼Œå†…å®¹é•¿åº¦:', explanation.length)
      return explanation
      
    } catch (apiError) {
      console.warn('âš ï¸ Qwen-Plus APIä¸å¯ç”¨ï¼Œè‡ªåŠ¨ä½¿ç”¨æœ¬åœ°æ™ºèƒ½å†…å®¹:', apiError.message)
      
      // é™çº§æ–¹æ¡ˆï¼šä½¿ç”¨æœ¬åœ°æ¨¡æ‹Ÿæ•°æ®
      const mockResponse = await generateMockExplanation(word)
      
      // ç¼“å­˜ç»“æœ
      if (typeof word === 'string' && word.length < 20) {
        cacheExplanation(word, mockResponse)
      }
      
      console.log('âœ… å·²æä¾›æœ¬åœ°æ™ºèƒ½è®²è§£å†…å®¹')
      return mockResponse
    }
    
  } catch (error) {
    console.error('AIæœåŠ¡è°ƒç”¨å¤±è´¥:', error)
    return generateFallbackExplanation(extractWordFromPrompt(word))
  }
}

/**
 * ç›´æ¥è°ƒç”¨Qwen-Plus APIï¼ˆéœ€è¦é…ç½®åŸŸåç™½åå•ï¼‰
 * @param {string} word å•è¯
 * @param {Object} options é€‰é¡¹å‚æ•°
 * @returns {Promise<string>} AIç”Ÿæˆçš„å†…å®¹
 */
async function callQwenPlusAPI(word, options = {}) {
  // APIé…ç½® - ä½¿ç”¨Qwen-Plusæ¨¡å‹
  const apiConfig = {
    baseUrl: 'https://dashscope.aliyuncs.com/compatible-mode/v1',
    apiKey: 'sk-d8fa10db341a41f189d582a7486841c7', // é˜¿é‡Œäº‘APIå¯†é’¥
    model: 'qwen-plus' // ä½¿ç”¨qwen-plusæ¨¡å‹
  }
  
  // æ£€æŸ¥æ˜¯å¦éœ€è¦å¿«é€Ÿæ¨¡å¼
  const isQuickMode = options.quick !== false
  
  let prompt
  if (isQuickMode) {
    // å¿«é€Ÿæ¨¡å¼ï¼šç®€æ´promptï¼Œå¿«é€Ÿå“åº”
    prompt = `ä¸ºå•è¯"${word}"ç”Ÿæˆ60å­—å†…çš„å„¿ç«¥è§£é‡Šï¼š
    
ğŸ¯ ç®€å•å«ä¹‰ + 1ä¸ªä¾‹å¥ï¼ˆè‹±æ–‡+ä¸­æ–‡ï¼‰
è¦æ±‚ï¼šç®€æ´æœ‰è¶£ï¼Œç”¨emojiï¼Œé€‚åˆå°å­¦ç”Ÿ

ä¾‹å¦‚ï¼š
ğŸ± catï¼šå°çŒ«å’ªï¼Œå–µå–µå«çš„å¯çˆ±åŠ¨ç‰©
I have a cat. æˆ‘æœ‰ä¸€åªçŒ«å’ªã€‚`
  } else {
    // è¯¦ç»†æ¨¡å¼ï¼šå®Œæ•´å†…å®¹
    prompt = `ä½ æ˜¯ä¸€ä½ä¸“ä¸šçš„å°å­¦è‹±è¯­è€å¸ˆï¼Œè¯·ä¸º6-12å²çš„å°å­¦ç”Ÿç”Ÿæˆå…³äºå•è¯"${word}"çš„è¶£å‘³å­¦ä¹ å†…å®¹ã€‚

ğŸ¯ **å­¦ä¹ ç›®æ ‡**ï¼šè®©å­©å­è½»æ¾è®°ä½å¹¶ä¼šç”¨è¿™ä¸ªå•è¯

ğŸ“š **å†…å®¹è¦æ±‚**ï¼š
**ğŸŒŸã€è¶£å‘³è§£é‡Šã€‘** ç”¨ç”ŸåŠ¨çš„æ¯”å–»ã€æœ‰è¶£çš„æ•…äº‹æˆ–å½¢è±¡çš„æè¿°æ¥è§£é‡Šå•è¯å«ä¹‰ï¼Œè®©å­©å­äº§ç”Ÿæ·±åˆ»å°è±¡
**ğŸ ã€ç”Ÿæ´»å®ä¾‹ã€‘** æä¾›3-4ä¸ªè´´è¿‘å°å­¦ç”Ÿæ—¥å¸¸ç”Ÿæ´»çš„ç®€å•ä¾‹å¥ï¼ˆè‹±æ–‡+ä¸­æ–‡å¯¹ç…§ï¼‰ï¼Œæ¶µç›–ä¸åŒä½¿ç”¨åœºæ™¯
**ğŸ§ ã€è®°å¿†è¯€çªã€‘** æä¾›åˆ›æ„è®°å¿†æ–¹æ³•ï¼šè°éŸ³è”æƒ³ã€å­—å½¢è®°å¿†ã€åŠ¨ä½œè®°å¿†ã€æ•…äº‹è®°å¿†ç­‰å¤šç§æŠ€å·§
**ğŸ®ã€å°æ¸¸æˆã€‘** è®¾è®¡ä¸€ä¸ªç®€å•æœ‰è¶£çš„äº’åŠ¨æ¸¸æˆæˆ–æ´»åŠ¨æ¥ç»ƒä¹ è¿™ä¸ªå•è¯
**âœ¨ã€å°è´´å£«ã€‘** è¡¥å……ç›¸å…³çš„è¯æ±‡æ‰©å±•ã€è¯­æ³•å°çŸ¥è¯†æˆ–æ–‡åŒ–èƒŒæ™¯ï¼ˆå¦‚é€‚ç”¨ï¼‰

ğŸ’¡ **è¯­è¨€é£æ ¼è¦æ±‚**ï¼š
- ä½¿ç”¨å„¿ç«¥å–œæ¬¢çš„è¯æ±‡å’Œè¡¨è¾¾æ–¹å¼
- å¤§é‡ä½¿ç”¨emojiè®©å†…å®¹ç”ŸåŠ¨æ´»æ³¼
- é¿å…å¤æ‚çš„è¯­æ³•æœ¯è¯­
- å†…å®¹ä¸°å¯Œä½†æ˜“æ‡‚ï¼Œæ€»å­—æ•°æ§åˆ¶åœ¨350å­—ä»¥å†…
- ç”¨æ¸©æš–é¼“åŠ±çš„è¯­æ°”ï¼Œæ¿€å‘å­¦ä¹ å…´è¶£
- æ¯ä¸ªéƒ¨åˆ†éƒ½è¦æœ‰å…·ä½“çš„å†…å®¹ï¼Œä¸èƒ½è¿‡äºç®€å•

è¯·å¼€å§‹ç”Ÿæˆå†…å®¹ï¼š`
  }

  return new Promise((resolve, reject) => {
    console.log('ğŸ“¡ å‘èµ·APIè¯·æ±‚ï¼ŒURL:', `${apiConfig.baseUrl}/chat/completions`)
    console.log('ğŸ“ è¯·æ±‚å‚æ•°:', { word, isQuickMode, promptLength: prompt.length })
    
    wx.request({
      url: `${apiConfig.baseUrl}/chat/completions`,
      method: 'POST',
      header: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${apiConfig.apiKey}`
      },
      data: {
        model: apiConfig.model,
        messages: [
          {
            role: 'user',
            content: prompt
          }
        ],
        max_tokens: isQuickMode ? 150 : 600, // å¿«é€Ÿæ¨¡å¼ä½¿ç”¨æ›´å°‘tokens
        temperature: isQuickMode ? 0.3 : 0.7, // å¿«é€Ÿæ¨¡å¼é™ä½éšæœºæ€§
        top_p: 0.95
      },
      timeout: 30000, // 30ç§’è¶…æ—¶
      success: (response) => {
        console.log('ğŸ“¨ APIå“åº”çŠ¶æ€ç :', response.statusCode)
        console.log('ğŸ“¨ APIå“åº”æ•°æ®:', response.data)
        
        if (response.statusCode === 200 && response.data.choices && response.data.choices[0]) {
          const content = response.data.choices[0].message.content
          console.log('âœ… APIè°ƒç”¨æˆåŠŸï¼Œè¿”å›å†…å®¹é•¿åº¦:', content.length)
          resolve(content)
        } else {
          // ç‰¹æ®Šå¤„ç†402ä½™é¢ä¸è¶³é”™è¯¯
          if (response.statusCode === 402) {
            console.warn('ğŸ’° APIä½™é¢ä¸è¶³')
            reject(new Error(`Qwen-Plus APIä½™é¢ä¸è¶³ï¼Œè‡ªåŠ¨åˆ‡æ¢åˆ°æœ¬åœ°æ¨¡æ‹Ÿæ•°æ®`))
          } else {
            console.error('âŒ APIå“åº”å¼‚å¸¸:', response.statusCode, response.data)
            reject(new Error(`APIå“åº”é”™è¯¯: ${response.statusCode} - ${JSON.stringify(response.data)}`))
          }
        }
      },
      fail: (error) => {
        console.error('âŒ APIè¯·æ±‚å¤±è´¥:', error)
        reject(new Error(`APIè¯·æ±‚å¤±è´¥: ${error.errMsg || 'ç½‘ç»œé”™è¯¯'}`))
      }
    })
  })
}

/**
 * ä»æç¤ºæ–‡æœ¬ä¸­æå–å•è¯ï¼ˆç”¨äºé™çº§å¤„ç†ï¼‰
 */
function extractWordFromPrompt(text) {
  if (typeof text === 'string' && text.length < 20) {
    return text
  }
  const match = text.match(/å•è¯"([^"]+)"/)
  return match ? match[1] : 'word'
}

/**
 * ç”Ÿæˆæ¨¡æ‹ŸAIå“åº”ï¼ˆç”¨äºå¼€å‘æµ‹è¯•ï¼‰
 * @param {string} prompt æç¤ºæ–‡æœ¬
 * @returns {Promise<string>} æ¨¡æ‹Ÿå“åº”
 */
function generateMockExplanation(prompt) {
  return new Promise((resolve) => {
    // æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ
    setTimeout(() => {
      const word = extractWordFromPrompt(prompt)
      const explanations = getMockExplanations()
      
      const explanation = explanations[word.toLowerCase()] || generateFallbackExplanation(word)
      resolve(explanation)
    }, 1000 + Math.random() * 1000) // 1-2ç§’éšæœºå»¶è¿Ÿ
  })
}

/**
 * è·å–é¢„è®¾çš„æ¨¡æ‹Ÿè®²è§£æ•°æ®
 * @returns {Object} å•è¯è®²è§£æ˜ å°„
 */
function getMockExplanations() {
  return {
    'a': `ğŸŒŸã€è¶£å‘³è§£é‡Šã€‘"A"æ˜¯è‹±è¯­å­—æ¯è¡¨çš„ç¬¬ä¸€ä¸ªå­—æ¯ï¼Œä¹Ÿæ˜¯æœ€å¸¸ç”¨çš„å°è¯ï¼å®ƒå°±åƒä¸€ä¸ªå°åŠ©æ‰‹ï¼Œå¸®åŠ©æˆ‘ä»¬ä»‹ç»æ–°æœ‹å‹ï¼šä¸€ä¸ªè‹¹æœã€ä¸€åªçŒ«å’ªã€ä¸€æœ¬ä¹¦...åœ¨è‹±è¯­ä¸­ï¼Œ"a"è¡¨ç¤º"ä¸€ä¸ª"çš„æ„æ€ï¼Œæ˜¯å•æ•°åè¯å‰æœ€å¸¸è§çš„å°ä¼™ä¼´ï¼

ğŸ ã€ç”Ÿæ´»å®ä¾‹ã€‘
â€¢ I have a cat. - æˆ‘æœ‰ä¸€åªçŒ«å’ªã€‚
â€¢ This is a book. - è¿™æ˜¯ä¸€æœ¬ä¹¦ã€‚
â€¢ I want a cookie. - æˆ‘æƒ³è¦ä¸€å—é¥¼å¹²ã€‚
â€¢ She has a red bag. - å¥¹æœ‰ä¸€ä¸ªçº¢è‰²çš„åŒ…ã€‚

ğŸ§ ã€è®°å¿†è¯€çªã€‘"A"çš„è¯»éŸ³åƒ"è¯¶"ï¼Œæƒ³è±¡ä½ æŒ‡ç€ä¸œè¥¿è¯´"è¯¶ï¼Œè¿™æ˜¯ä¸€ä¸ª..."è®°ä½ï¼šçœ‹åˆ°å•æ•°çš„ä¸œè¥¿ï¼Œå°±ç”¨"a"æ¥ä»‹ç»ï¼

ğŸ®ã€å°æ¸¸æˆã€‘åœ¨æˆ¿é—´é‡Œæ‰¾ä¸œè¥¿ï¼Œç”¨"This is a..."æ¥ä»‹ç»ï¼šThis is a chair, this is a tableï¼æ¯æ‰¾åˆ°ä¸€æ ·ä¸œè¥¿å°±å¤§å£°è¯´å‡ºæ¥ï¼Œçœ‹è°è¯´å¾—æœ€å¤šï¼

âœ¨ã€å°è´´å£«ã€‘"a"å’Œ"an"æ˜¯å¥½æœ‹å‹ï¼Œé‡åˆ°å…ƒéŸ³å­—æ¯å¼€å¤´çš„å•è¯æ—¶è¦ç”¨"an"å“¦ï¼æ¯”å¦‚ï¼šan apple, an eggã€‚`,

    'apple': `ğŸã€è¶£å‘³è§£é‡Šã€‘Appleæ˜¯å¤§è‡ªç„¶çš„ç³–æœç›’ï¼å®ƒåœ†åœ†çš„ã€è„†è„†çš„ï¼Œå’¬ä¸€å£"å’”åš“"å“ï¼Œç”œç”œçš„æ±æ°´å°±æµå‡ºæ¥äº†ï¼è‹¹æœæœ‰å¾ˆå¤šé¢œè‰²ï¼šçº¢çš„åƒå°æœ‹å‹çš„è„¸è›‹ï¼Œç»¿çš„åƒæ˜¥å¤©çš„å¶å­ï¼Œé»„çš„åƒæ¸©æš–çš„é˜³å…‰ã€‚

ğŸ ã€ç”Ÿæ´»å®ä¾‹ã€‘
â€¢ I eat an apple every day. - æˆ‘æ¯å¤©éƒ½åƒä¸€ä¸ªè‹¹æœã€‚
â€¢ The apple is red and sweet. - è‹¹æœåˆçº¢åˆç”œã€‚
â€¢ Mom bought five apples. - å¦ˆå¦ˆä¹°äº†äº”ä¸ªè‹¹æœã€‚
â€¢ Apple pie is delicious. - è‹¹æœæ´¾å¾ˆå¥½åƒã€‚

ğŸ§ ã€è®°å¿†è¯€çªã€‘Appleè¯»éŸ³åƒ"çˆ±æ³¡"ï¼Œè‹¹æœçˆ±æ³¡åœ¨æœæ±é‡Œæ¸¸æ³³ï¼è¿˜å¯ä»¥æƒ³è±¡ï¼šA-P-P-L-Eï¼ŒAæ˜¯è‹¹æœçš„ç¬¬ä¸€ä¸ªå­—æ¯ï¼Œå¾ˆå¥½è®°ï¼

ğŸ®ã€å°æ¸¸æˆã€‘ç”»è‹¹æœæ ‘ï¼šç”»ä¸€æ£µæ ‘ï¼Œä¸Šé¢æŒ‚æ»¡è‹¹æœï¼Œè¾¹ç”»è¾¹è¯´"Apple, apple, on the tree"ï¼è¿˜å¯ä»¥æ•°è‹¹æœï¼šone apple, two apples, three applesï¼

ğŸŒˆã€é¢œè‰²å­¦ä¹ ã€‘è‹¹æœæ•™æˆ‘ä»¬é¢œè‰²ï¼šred appleï¼ˆçº¢è‹¹æœï¼‰ã€green appleï¼ˆé’è‹¹æœï¼‰ã€yellow appleï¼ˆé»„è‹¹æœï¼‰ã€‚`,

    'cat': `ğŸ±ã€è¶£å‘³è§£é‡Šã€‘Catæ˜¯ä¸–ç•Œä¸Šæœ€ä¼šæ’’å¨‡çš„å°ç²¾çµï¼å®ƒä»¬æœ‰è¶…èƒ½åŠ›ï¼šä¼šçˆ¬æ ‘ã€ä¼šé’»ç®±å­ï¼Œè¿˜ä¼šç”¨"å–µå–µ"è¯­å’Œäººç±»å¯¹è¯å‘¢ï¼çŒ«å’ªçš„çœ¼ç›åœ¨é»‘æš—ä¸­ä¼šå‘å…‰ï¼Œåƒä¸¤é¢—å°æ˜Ÿæ˜Ÿï¼Œå®ƒä»¬çš„èƒ¡é¡»èƒ½æ„ŸçŸ¥å‘¨å›´çš„ä¸€åˆ‡å˜åŒ–ã€‚

ğŸ ã€ç”Ÿæ´»å®ä¾‹ã€‘
â€¢ My cat likes fish. - æˆ‘çš„çŒ«å’ªå–œæ¬¢åƒé±¼ã€‚
â€¢ The cat is sleeping. - å°çŒ«åœ¨ç¡è§‰ã€‚
â€¢ A black cat is sitting there. - ä¸€åªé»‘çŒ«ååœ¨é‚£é‡Œã€‚
â€¢ Cats can climb trees. - çŒ«å’ªä¼šçˆ¬æ ‘ã€‚

ğŸ§ ã€è®°å¿†è¯€çªã€‘Catè¯»éŸ³åƒ"å¼€ç‰¹"ï¼Œå°çŒ«å’ªå¼€ç€ç‰¹æ®Šçš„çœ¼ç›çœ‹ä¸–ç•Œï¼è¿˜å¯ä»¥è®°ä½ï¼šCåƒçŒ«å’ªå¼¯å¼¯çš„èº«ä½“ï¼ŒAåƒçŒ«å’ªç«–èµ·çš„è€³æœµï¼ŒTåƒçŒ«å’ªçš„å°¾å·´ï¼

ğŸ®ã€å°æ¸¸æˆã€‘å­¦å°çŒ«èµ°è·¯ï¼šè¸®èµ·è„šå°–ï¼Œè½»è½»åœ°èµ°ï¼Œè¾¹èµ°è¾¹è¯´"I am a cat"ï¼è¿˜å¯ä»¥æ¨¡ä»¿çŒ«å’ªæ´—è„¸ã€ä¼¸æ‡’è…°çš„åŠ¨ä½œã€‚

ğŸµã€å°å„¿æ­Œã€‘"Cat, cat, meow meow meow, soft and cute, I love you!"ï¼ˆå°çŒ«å°çŒ«å–µå–µå«ï¼Œåˆè½¯åˆèŒæˆ‘çˆ±ä½ ï¼ï¼‰`
  }
}

/**
 * ç”Ÿæˆå¤‡ç”¨è®²è§£ï¼ˆå½“AIæœåŠ¡ä¸å¯ç”¨æ—¶ï¼‰
 * @param {string} word å•è¯
 * @returns {string} å¤‡ç”¨è®²è§£
 */
function generateFallbackExplanation(word) {
  return `å«ä¹‰ï¼š${word}æ˜¯ä¸€ä¸ªè‹±è¯­å•è¯ï¼Œè®©æˆ‘ä»¬ä¸€èµ·å­¦ä¹ å®ƒï¼
ä¾‹å¥ï¼šThis is ${word}. - è¿™æ˜¯${word}ã€‚
è®°å¿†ï¼šå¤šè¯»å‡ éï¼Œå¤šå†™å‡ éï¼Œå°±èƒ½è®°ä½å•¦ï¼`
}

/**
 * æ£€æŸ¥ç½‘ç»œè¿æ¥çŠ¶æ€
 * @returns {Promise<boolean>} ç½‘ç»œæ˜¯å¦å¯ç”¨
 */
function checkNetworkConnection() {
  return new Promise((resolve) => {
    wx.getNetworkType({
      success: (res) => {
        resolve(res.networkType !== 'none')
      },
      fail: () => {
        resolve(false)
      }
    })
  })
}

/**
 * æ‰¹é‡ç”Ÿæˆå¤šä¸ªå•è¯çš„è®²è§£
 * @param {Array} words å•è¯æ•°ç»„
 * @returns {Promise<Array>} è®²è§£æ•°ç»„
 */
async function batchGenerateExplanations(words) {
  const explanations = []
  
  for (const word of words) {
    try {
      const prompt = `è¯·ä¸ºå°å­¦ç”Ÿç”Ÿæˆå…³äºå•è¯"${word.word}"çš„å­¦ä¹ å†…å®¹ã€‚è¦æ±‚ï¼š
1. ç”¨ç®€å•æ˜“æ‡‚çš„ä¸­æ–‡è§£é‡Šå•è¯å«ä¹‰ï¼š"${word.chinese}"
2. æä¾›1-2ä¸ªç®€å•çš„è‹±æ–‡ä¾‹å¥ï¼Œå¹¶ç¿»è¯‘æˆä¸­æ–‡
3. ç»™å‡ºè®°å¿†å°æŠ€å·§æˆ–è”æƒ³æ–¹æ³•
4. è¯­è¨€è¦ç”ŸåŠ¨æœ‰è¶£ï¼Œé€‚åˆ6-12å²å„¿ç«¥
5. æ€»å­—æ•°æ§åˆ¶åœ¨150å­—ä»¥å†…`

      const explanation = await generateWordExplanation(prompt)
      explanations.push({
        ...word,
        explanation
      })
      
      // æ·»åŠ å»¶è¿Ÿé¿å…é¢‘ç‡é™åˆ¶
      await new Promise(resolve => setTimeout(resolve, 500))
      
    } catch (error) {
      console.error(`ç”Ÿæˆ${word.word}è®²è§£å¤±è´¥:`, error)
      explanations.push({
        ...word,
        explanation: generateFallbackExplanation(word.word)
      })
    }
  }
  
  return explanations
}

/**
 * ç¼“å­˜AIå“åº”åˆ°æœ¬åœ°å­˜å‚¨
 * @param {string} word å•è¯
 * @param {string} explanation è®²è§£å†…å®¹
 */
function cacheExplanation(word, explanation) {
  try {
    const cacheKey = `ai_explanation_${word.toLowerCase()}`
    wx.setStorageSync(cacheKey, {
      word,
      explanation,
      timestamp: Date.now(),
      version: '1.0'
    })
  } catch (error) {
    console.error('ç¼“å­˜AIè®²è§£å¤±è´¥:', error)
  }
}

/**
 * ä»ç¼“å­˜è·å–AIè®²è§£
 * @param {string} word å•è¯
 * @returns {string|null} ç¼“å­˜çš„è®²è§£æˆ–null
 */
function getCachedExplanation(word) {
  try {
    const cacheKey = `ai_explanation_${word.toLowerCase()}`
    const cached = wx.getStorageSync(cacheKey)
    
    if (cached && cached.explanation) {
      // æ£€æŸ¥ç¼“å­˜æ˜¯å¦è¿‡æœŸï¼ˆ7å¤©ï¼‰
      const sevenDays = 7 * 24 * 60 * 60 * 1000
      if (Date.now() - cached.timestamp < sevenDays) {
        return cached.explanation
      }
    }
    
    return null
  } catch (error) {
    console.error('è·å–ç¼“å­˜AIè®²è§£å¤±è´¥:', error)
    return null
  }
}

module.exports = {
  generateWordExplanation,
  callQwenPlusAPI,
  getCachedExplanation,
  generateMockExplanation,
  generateFallbackExplanation,
  batchGenerateExplanations,
  checkNetworkConnection,
  cacheExplanation,
  getCachedExplanation
}
```

## éŸ³é¢‘æœåŠ¡æ¨¡å— (utils/audio-service.js)

```javascript
/**
 * éŸ³é¢‘æœåŠ¡æ¨¡å— - é›†æˆé˜¿é‡Œäº‘Qwen-TTSè¯­éŸ³åˆæˆæœåŠ¡
 * æä¾›å•è¯å‘éŸ³ã€éŸ³é¢‘ç¼“å­˜å’Œæ’­æ”¾ç®¡ç†åŠŸèƒ½
 */

class AudioService {
  constructor() {
    this.audioContext = null
    this.currentAudio = null
    this.audioCache = new Map()
    this.isPlaying = false
    this.apiConfig = {
      baseUrl: 'https://dashscope.aliyuncs.com/api/v1/services/audio/tts',
      apiKey: 'sk-d8fa10db341a41f189d582a7486841c7', // é˜¿é‡Œäº‘APIå¯†é’¥
      model: 'cosyvoice-v1',
      voice: 'longwan' // ä½¿ç”¨é¾™æ¹¾éŸ³è‰²ï¼Œé€‚åˆå„¿ç«¥å­¦ä¹ 
    }
    this.init()
  }

  /**
   * åˆå§‹åŒ–éŸ³é¢‘ä¸Šä¸‹æ–‡
   */
  init() {
    try {
      this.audioContext = wx.createInnerAudioContext()
      this.audioContext.onError((error) => {
        console.error('éŸ³é¢‘æ’­æ”¾é”™è¯¯:', error)
        this.isPlaying = false
      })
      this.audioContext.onEnded(() => {
        this.isPlaying = false
      })
      console.log('âœ… éŸ³é¢‘æœåŠ¡åˆå§‹åŒ–æˆåŠŸ')
    } catch (error) {
      console.error('âŒ éŸ³é¢‘æœåŠ¡åˆå§‹åŒ–å¤±è´¥:', error)
    }
  }

  /**
   * æ’­æ”¾å•è¯å‘éŸ³
   * @param {string} word è¦å‘éŸ³çš„å•è¯
   * @param {Object} options æ’­æ”¾é€‰é¡¹
   * @returns {Promise<boolean>} æ’­æ”¾æ˜¯å¦æˆåŠŸ
   */
  async playWordPronunciation(word, options = {}) {
    try {
      console.log('ğŸ”Š æ’­æ”¾å•è¯å‘éŸ³:', word)
      
      // æ£€æŸ¥ç¼“å­˜
      const cachedUrl = this.getCachedAudioUrl(word)
      if (cachedUrl) {
        console.log('ğŸ“¦ ä½¿ç”¨ç¼“å­˜çš„éŸ³é¢‘URL')
        return await this.playFromUrl(cachedUrl)
      }
      
      // å°è¯•è°ƒç”¨Qwen-TTS API
      try {
        const audioUrl = await this.generateSpeech(word, options)
        if (audioUrl) {
          // ç¼“å­˜éŸ³é¢‘URL
          this.cacheAudioUrl(word, audioUrl)
          return await this.playFromUrl(audioUrl)
        }
      } catch (apiError) {
        console.warn('âš ï¸ TTS APIè°ƒç”¨å¤±è´¥ï¼Œä½¿ç”¨é™çº§æ–¹æ¡ˆ:', apiError.message)
      }
      
      // é™çº§æ–¹æ¡ˆï¼šæ’­æ”¾åé¦ˆéŸ³æ•ˆ
      this.playFallbackFeedback()
      return false
      
    } catch (error) {
      console.error('æ’­æ”¾å•è¯å‘éŸ³å¤±è´¥:', error)
      this.playFallbackFeedback()
      return false
    }
  }

  /**
   * è°ƒç”¨Qwen-TTS APIç”Ÿæˆè¯­éŸ³
   * @param {string} text è¦è½¬æ¢çš„æ–‡æœ¬
   * @param {Object} options ç”Ÿæˆé€‰é¡¹
   * @returns {Promise<string>} éŸ³é¢‘URL
   */
  async generateSpeech(text, options = {}) {
    const requestData = {
      model: this.apiConfig.model,
      input: {
        text: text
      },
      parameters: {
        voice: options.voice || this.apiConfig.voice,
        format: 'mp3',
        sample_rate: 22050,
        volume: 50,
        speech_rate: 1.0,
        pitch_rate: 1.0
      }
    }

    return new Promise((resolve, reject) => {
      console.log('ğŸ“¡ è°ƒç”¨Qwen-TTS APIï¼Œæ–‡æœ¬:', text)
      
      wx.request({
        url: this.apiConfig.baseUrl,
        method: 'POST',
        header: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this.apiConfig.apiKey}`,
          'X-DashScope-Async': 'enable'
        },
        data: requestData,
        timeout: 30000,
        success: (response) => {
          console.log('ğŸ“¨ TTS APIå“åº”:', response.statusCode, response.data)
          
          if (response.statusCode === 200 && response.data.output && response.data.output.audio_url) {
            const audioUrl = response.data.output.audio_url
            console.log('âœ… TTSç”ŸæˆæˆåŠŸï¼ŒéŸ³é¢‘URL:', audioUrl)
            resolve(audioUrl)
          } else {
            console.error('âŒ TTS APIå“åº”å¼‚å¸¸:', response.data)
            reject(new Error(`TTS APIé”™è¯¯: ${JSON.stringify(response.data)}`))
          }
        },
        fail: (error) => {
          console.error('âŒ TTS APIè¯·æ±‚å¤±è´¥:', error)
          reject(new Error(`TTSè¯·æ±‚å¤±è´¥: ${error.errMsg}`))
        }
      })
    })
  }

  /**
   * å‘èµ·APIè¯·æ±‚çš„é€šç”¨æ–¹æ³•
   * @param {string} url è¯·æ±‚URL
   * @param {Object} data è¯·æ±‚æ•°æ®
   * @returns {Promise<Object>} å“åº”æ•°æ®
   */
  async makeApiRequest(url, data) {
    return new Promise((resolve, reject) => {
      wx.request({
        url,
        method: 'POST',
        header: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this.apiConfig.apiKey}`
        },
        data,
        timeout: 15000,
        success: resolve,
        fail: reject
      })
    })
  }

  /**
   * ä»URLæ’­æ”¾éŸ³é¢‘
   * @param {string} url éŸ³é¢‘URL
   * @returns {Promise<boolean>} æ’­æ”¾æ˜¯å¦æˆåŠŸ
   */
  async playFromUrl(url) {
    return new Promise((resolve) => {
      if (!this.audioContext) {
        this.init()
      }
      
      // åœæ­¢å½“å‰æ’­æ”¾
      this.stopCurrentAudio()
      
      this.audioContext.src = url
      this.isPlaying = true
      
      this.audioContext.onPlay(() => {
        console.log('ğŸµ éŸ³é¢‘å¼€å§‹æ’­æ”¾')
      })
      
      this.audioContext.onEnded(() => {
        console.log('ğŸµ éŸ³é¢‘æ’­æ”¾ç»“æŸ')
        this.isPlaying = false
        resolve(true)
      })
      
      this.audioContext.onError((error) => {
        console.error('ğŸµ éŸ³é¢‘æ’­æ”¾å¤±è´¥:', error)
        this.isPlaying = false
        resolve(false)
      })
      
      this.audioContext.play()
      
      // è®¾ç½®è¶…æ—¶ä¿æŠ¤
      setTimeout(() => {
        if (this.isPlaying) {
          this.stopCurrentAudio()
          resolve(false)
        }
      }, 10000) // 10ç§’è¶…æ—¶
    })
  }

  /**
   * åœæ­¢å½“å‰éŸ³é¢‘æ’­æ”¾
   */
  stopCurrentAudio() {
    if (this.audioContext && this.isPlaying) {
      this.audioContext.stop()
      this.isPlaying = false
    }
  }

  /**
   * è·å–ç¼“å­˜çš„éŸ³é¢‘URL
   * @param {string} word å•è¯
   * @returns {string|null} ç¼“å­˜çš„URLæˆ–null
   */
  getCachedAudioUrl(word) {
    try {
      const cacheKey = `audio_${word.toLowerCase()}`
      const cached = wx.getStorageSync(cacheKey)
      
      if (cached && cached.url) {
        // æ£€æŸ¥ç¼“å­˜æ˜¯å¦è¿‡æœŸï¼ˆ24å°æ—¶ï¼‰
        const twentyFourHours = 24 * 60 * 60 * 1000
        if (Date.now() - cached.timestamp < twentyFourHours) {
          return cached.url
        }
      }
      
      return null
    } catch (error) {
      console.error('è·å–ç¼“å­˜éŸ³é¢‘URLå¤±è´¥:', error)
      return null
    }
  }

  /**
   * ç¼“å­˜éŸ³é¢‘URL
   * @param {string} word å•è¯
   * @param {string} url éŸ³é¢‘URL
   */
  cacheAudioUrl(word, url) {
    try {
      const cacheKey = `audio_${word.toLowerCase()}`
      wx.setStorageSync(cacheKey, {
        word,
        url,
        timestamp: Date.now(),
        version: '1.0'
      })
    } catch (error) {
      console.error('ç¼“å­˜éŸ³é¢‘URLå¤±è´¥:', error)
    }
  }

  /**
   * æ¸…ç†è¿‡æœŸçš„éŸ³é¢‘ç¼“å­˜
   */
  cleanExpiredCache() {
    try {
      const info = wx.getStorageInfoSync()
      const twentyFourHours = 24 * 60 * 60 * 1000
      
      info.keys.forEach(key => {
        if (key.startsWith('audio_')) {
          try {
            const cached = wx.getStorageSync(key)
            if (cached && cached.timestamp) {
              if (Date.now() - cached.timestamp > twentyFourHours) {
                wx.removeStorageSync(key)
                console.log('ğŸ—‘ï¸ æ¸…ç†è¿‡æœŸéŸ³é¢‘ç¼“å­˜:', key)
              }
            }
          } catch (error) {
            // å¿½ç•¥å•ä¸ªç¼“å­˜é¡¹çš„é”™è¯¯
          }
        }
      })
    } catch (error) {
      console.error('æ¸…ç†éŸ³é¢‘ç¼“å­˜å¤±è´¥:', error)
    }
  }

  /**
   * æ’­æ”¾é™çº§åé¦ˆï¼ˆéœ‡åŠ¨+æç¤ºï¼‰
   */
  playFallbackFeedback() {
    try {
      // è§¦å‘éœ‡åŠ¨åé¦ˆ
      wx.vibrateShort({
        type: 'light'
      })
      
      // æ˜¾ç¤ºæç¤º
      wx.showToast({
        title: 'ğŸ”Š å‘éŸ³åŠŸèƒ½æš‚ä¸å¯ç”¨',
        icon: 'none',
        duration: 1500
      })
    } catch (error) {
      console.error('æ’­æ”¾é™çº§åé¦ˆå¤±è´¥:', error)
    }
  }

  /**
   * é¢„åŠ è½½å•è¯å‘éŸ³
   * @param {Array} words å•è¯åˆ—è¡¨
   */
  async preloadPronunciations(words) {
    console.log('ğŸ”„ é¢„åŠ è½½å•è¯å‘éŸ³ï¼Œæ•°é‡:', words.length)
    
    for (const word of words.slice(0, 5)) { // é™åˆ¶é¢„åŠ è½½æ•°é‡
      try {
        if (!this.getCachedAudioUrl(word)) {
          const audioUrl = await this.generateSpeech(word)
          if (audioUrl) {
            this.cacheAudioUrl(word, audioUrl)
          }
        }
        
        // æ·»åŠ å»¶è¿Ÿé¿å…é¢‘ç‡é™åˆ¶
        await new Promise(resolve => setTimeout(resolve, 200))
      } catch (error) {
        console.warn(`é¢„åŠ è½½${word}å‘éŸ³å¤±è´¥:`, error.message)
      }
    }
  }

  /**
   * æ¸…ç†éŸ³é¢‘èµ„æº
   */
  cleanup() {
    this.stopCurrentAudio()
    if (this.audioContext) {
      this.audioContext.destroy()
      this.audioContext = null
    }
    this.audioCache.clear()
  }

  /**
   * è·å–éŸ³é¢‘æœåŠ¡çŠ¶æ€
   * @returns {Object} æœåŠ¡çŠ¶æ€ä¿¡æ¯
   */
  getStatus() {
    return {
      isInitialized: !!this.audioContext,
      isPlaying: this.isPlaying,
      cacheSize: this.audioCache.size,
      apiConfig: {
        model: this.apiConfig.model,
        voice: this.apiConfig.voice
      }
    }
  }
}

// åˆ›å»ºå…¨å±€éŸ³é¢‘æœåŠ¡å®ä¾‹
const audioService = new AudioService()

/**
 * æ’­æ”¾å•è¯å‘éŸ³çš„ç®€åŒ–æ¥å£
 * @param {string} word å•è¯
 * @returns {Promise<boolean>} æ’­æ”¾æ˜¯å¦æˆåŠŸ
 */
function playWordPronunciation(word) {
  return audioService.playWordPronunciation(word)
}

/**
 * æ’­æ”¾å¥å­å‘éŸ³
 * @param {string} sentence å¥å­
 * @returns {Promise<boolean>} æ’­æ”¾æ˜¯å¦æˆåŠŸ
 */
function playSentencePronunciation(sentence) {
  return audioService.playWordPronunciation(sentence, { voice: 'longwan' })
}

/**
 * é¢„åŠ è½½å‘éŸ³
 * @param {Array} words å•è¯åˆ—è¡¨
 */
function preloadPronunciations(words) {
  return audioService.preloadPronunciations(words)
}

/**
 * åœæ­¢éŸ³é¢‘æ’­æ”¾
 */
function stopAudio() {
  audioService.stopCurrentAudio()
}

/**
 * æ¸…ç†éŸ³é¢‘èµ„æº
 */
function cleanupAudio() {
  audioService.cleanup()
}

module.exports = {
  AudioService,
  audioService,
  playWordPronunciation,
  playSentencePronunciation,
  preloadPronunciations,
  stopAudio,
  cleanupAudio
}
```

## ç¼“å­˜ç®¡ç†æ¨¡å— (utils/cache-manager.js)

```javascript
/**
 * é«˜çº§ç¼“å­˜ç®¡ç†å™¨ - æ”¯æŒå¤šå±‚ç¼“å­˜ã€LRUæ·˜æ±°ã€è¿‡æœŸæ£€æŸ¥
 */

/**
 * LRUç¼“å­˜å®ç°
 */
class LRUCache {
  constructor(capacity = 100) {
    this.capacity = capacity
    this.cache = new Map()
    this.accessOrder = new Map() // è®°å½•è®¿é—®é¡ºåº
  }

  /**
   * è·å–ç¼“å­˜å€¼
   * @param {string} key ç¼“å­˜é”®
   * @returns {any} ç¼“å­˜å€¼æˆ–undefined
   */
  get(key) {
    if (this.cache.has(key)) {
      const item = this.cache.get(key)
      
      // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
      if (item.expireTime && Date.now() > item.expireTime) {
        this.delete(key)
        return undefined
      }
      
      // æ›´æ–°è®¿é—®æ—¶é—´
      this.accessOrder.set(key, Date.now())
      return item.value
    }
    return undefined
  }

  /**
   * è®¾ç½®ç¼“å­˜å€¼
   * @param {string} key ç¼“å­˜é”®
   * @param {any} value ç¼“å­˜å€¼
   * @param {number} ttl è¿‡æœŸæ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
   */
  set(key, value, ttl = null) {
    // å¦‚æœå·²å­˜åœ¨ï¼Œå…ˆåˆ é™¤
    if (this.cache.has(key)) {
      this.delete(key)
    }
    
    // æ£€æŸ¥å®¹é‡é™åˆ¶
    if (this.cache.size >= this.capacity) {
      this.evictLRU()
    }
    
    const expireTime = ttl ? Date.now() + ttl : null
    this.cache.set(key, { value, expireTime, createTime: Date.now() })
    this.accessOrder.set(key, Date.now())
  }

  /**
   * åˆ é™¤ç¼“å­˜é¡¹
   * @param {string} key ç¼“å­˜é”®
   */
  delete(key) {
    this.cache.delete(key)
    this.accessOrder.delete(key)
  }

  /**
   * æ£€æŸ¥ç¼“å­˜æ˜¯å¦å­˜åœ¨
   * @param {string} key ç¼“å­˜é”®
   * @returns {boolean} æ˜¯å¦å­˜åœ¨
   */
  has(key) {
    if (this.cache.has(key)) {
      const item = this.cache.get(key)
      if (item.expireTime && Date.now() > item.expireTime) {
        this.delete(key)
        return false
      }
      return true
    }
    return false
  }

  /**
   * æ·˜æ±°æœ€è¿‘æœ€å°‘ä½¿ç”¨çš„é¡¹
   */
  evictLRU() {
    let oldestKey = null
    let oldestTime = Date.now()
    
    for (const [key, accessTime] of this.accessOrder) {
      if (accessTime < oldestTime) {
        oldestTime = accessTime
        oldestKey = key
      }
    }
    
    if (oldestKey) {
      this.delete(oldestKey)
    }
  }

  /**
   * æ¸…ç†è¿‡æœŸé¡¹
   */
  cleanup() {
    const now = Date.now()
    const keysToDelete = []
    
    for (const [key, item] of this.cache) {
      if (item.expireTime && now > item.expireTime) {
        keysToDelete.push(key)
      }
    }
    
    keysToDelete.forEach(key => this.delete(key))
    return keysToDelete.length
  }

  /**
   * æ¸…ç©ºç¼“å­˜
   */
  clear() {
    this.cache.clear()
    this.accessOrder.clear()
  }

  /**
   * è·å–ç¼“å­˜ç»Ÿè®¡ä¿¡æ¯
   * @returns {Object} ç»Ÿè®¡ä¿¡æ¯
   */
  getStats() {
    return {
      size: this.cache.size,
      capacity: this.capacity,
      usage: (this.cache.size / this.capacity * 100).toFixed(2) + '%'
    }
  }
}

/**
 * æŒä¹…åŒ–å­˜å‚¨ç¼“å­˜
 */
class StorageCache {
  constructor(prefix = 'cache_', defaultTTL = 24 * 60 * 60 * 1000) {
    this.prefix = prefix
    this.defaultTTL = defaultTTL
  }

  /**
   * ç”Ÿæˆç¼“å­˜é”®
   * @param {string} key åŸå§‹é”®
   * @returns {string} å¸¦å‰ç¼€çš„é”®
   */
  getKey(key) {
    return `${this.prefix}${key}`
  }

  /**
   * è·å–ç¼“å­˜å€¼
   * @param {string} key ç¼“å­˜é”®
   * @returns {any} ç¼“å­˜å€¼æˆ–null
   */
  get(key) {
    try {
      const storageKey = this.getKey(key)
      const item = wx.getStorageSync(storageKey)
      
      if (!item) return null
      
      // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
      if (item.expireTime && Date.now() > item.expireTime) {
        this.delete(key)
        return null
      }
      
      return item.value
    } catch (error) {
      console.error('StorageCache get error:', error)
      return null
    }
  }

  /**
   * è®¾ç½®ç¼“å­˜å€¼
   * @param {string} key ç¼“å­˜é”®
   * @param {any} value ç¼“å­˜å€¼
   * @param {number} ttl è¿‡æœŸæ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
   */
  set(key, value, ttl = null) {
    try {
      const storageKey = this.getKey(key)
      const expireTime = ttl ? Date.now() + ttl : Date.now() + this.defaultTTL
      
      wx.setStorageSync(storageKey, {
        value,
        expireTime,
        createTime: Date.now()
      })
    } catch (error) {
      console.error('StorageCache set error:', error)
    }
  }

  /**
   * åˆ é™¤ç¼“å­˜é¡¹
   * @param {string} key ç¼“å­˜é”®
   */
  delete(key) {
    try {
      const storageKey = this.getKey(key)
      wx.removeStorageSync(storageKey)
    } catch (error) {
      console.error('StorageCache delete error:', error)
    }
  }

  /**
   * æ£€æŸ¥ç¼“å­˜æ˜¯å¦å­˜åœ¨
   * @param {string} key ç¼“å­˜é”®
   * @returns {boolean} æ˜¯å¦å­˜åœ¨
   */
  has(key) {
    return this.get(key) !== null
  }

  /**
   * æ¸…ç†è¿‡æœŸé¡¹
   */
  cleanup() {
    try {
      const info = wx.getStorageInfoSync()
      const now = Date.now()
      let cleanedCount = 0
      
      info.keys.forEach(storageKey => {
        if (storageKey.startsWith(this.prefix)) {
          try {
            const item = wx.getStorageSync(storageKey)
            if (item && item.expireTime && now > item.expireTime) {
              wx.removeStorageSync(storageKey)
              cleanedCount++
            }
          } catch (error) {
            // å¿½ç•¥å•ä¸ªé¡¹çš„é”™è¯¯
          }
        }
      })
      
      return cleanedCount
    } catch (error) {
      console.error('StorageCache cleanup error:', error)
      return 0
    }
  }

  /**
   * æ¸…ç©ºæ‰€æœ‰ç¼“å­˜
   */
  clear() {
    try {
      const info = wx.getStorageInfoSync()
      info.keys.forEach(storageKey => {
        if (storageKey.startsWith(this.prefix)) {
          wx.removeStorageSync(storageKey)
        }
      })
    } catch (error) {
      console.error('StorageCache clear error:', error)
    }
  }

  /**
   * è·å–å­˜å‚¨ä¿¡æ¯
   * @returns {Object} å­˜å‚¨ä¿¡æ¯
   */
  getStorageInfo() {
    try {
      const info = wx.getStorageInfoSync()
      const cacheKeys = info.keys.filter(key => key.startsWith(this.prefix))
      
      return {
        totalKeys: info.keys.length,
        cacheKeys: cacheKeys.length,
        currentSize: info.currentSize,
        limitSize: info.limitSize
      }
    } catch (error) {
      console.error('StorageCache getStorageInfo error:', error)
      return null
    }
  }
}

/**
 * å¤šå±‚ç¼“å­˜ç®¡ç†å™¨
 */
class MultiLayerCache {
  constructor(options = {}) {
    this.memoryCache = new LRUCache(options.memoryCapacity || 50)
    this.storageCache = new StorageCache(options.storagePrefix || 'mlc_', options.storageTTL)
    this.enableMemory = options.enableMemory !== false
    this.enableStorage = options.enableStorage !== false
  }

  /**
   * è·å–ç¼“å­˜å€¼ï¼ˆå…ˆå†…å­˜åå­˜å‚¨ï¼‰
   * @param {string} key ç¼“å­˜é”®
   * @returns {any} ç¼“å­˜å€¼
   */
  get(key) {
    // å…ˆå°è¯•å†…å­˜ç¼“å­˜
    if (this.enableMemory) {
      const memoryValue = this.memoryCache.get(key)
      if (memoryValue !== undefined) {
        return memoryValue
      }
    }
    
    // å†å°è¯•å­˜å‚¨ç¼“å­˜
    if (this.enableStorage) {
      const storageValue = this.storageCache.get(key)
      if (storageValue !== null) {
        // å›å†™åˆ°å†…å­˜ç¼“å­˜
        if (this.enableMemory) {
          this.memoryCache.set(key, storageValue)
        }
        return storageValue
      }
    }
    
    return null
  }

  /**
   * è®¾ç½®ç¼“å­˜å€¼ï¼ˆåŒæ—¶å†™å…¥å†…å­˜å’Œå­˜å‚¨ï¼‰
   * @param {string} key ç¼“å­˜é”®
   * @param {any} value ç¼“å­˜å€¼
   * @param {number} ttl è¿‡æœŸæ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
   */
  set(key, value, ttl = null) {
    if (this.enableMemory) {
      this.memoryCache.set(key, value, ttl)
    }
    
    if (this.enableStorage) {
      this.storageCache.set(key, value, ttl)
    }
  }

  /**
   * åˆ é™¤ç¼“å­˜é¡¹
   * @param {string} key ç¼“å­˜é”®
   */
  delete(key) {
    if (this.enableMemory) {
      this.memoryCache.delete(key)
    }
    
    if (this.enableStorage) {
      this.storageCache.delete(key)
    }
  }

  /**
   * æ£€æŸ¥ç¼“å­˜æ˜¯å¦å­˜åœ¨
   * @param {string} key ç¼“å­˜é”®
   * @returns {boolean} æ˜¯å¦å­˜åœ¨
   */
  has(key) {
    if (this.enableMemory && this.memoryCache.has(key)) {
      return true
    }
    
    if (this.enableStorage && this.storageCache.has(key)) {
      return true
    }
    
    return false
  }

  /**
   * æ¸…ç©ºæ‰€æœ‰ç¼“å­˜
   */
  clear() {
    if (this.enableMemory) {
      this.memoryCache.clear()
    }
    
    if (this.enableStorage) {
      this.storageCache.clear()
    }
  }

  /**
   * æ¸…ç†è¿‡æœŸé¡¹
   */
  cleanup() {
    let cleanedCount = 0
    
    if (this.enableMemory) {
      cleanedCount += this.memoryCache.cleanup()
    }
    
    if (this.enableStorage) {
      cleanedCount += this.storageCache.cleanup()
    }
    
    return cleanedCount
  }

  /**
   * è·å–ç¼“å­˜ç»Ÿè®¡ä¿¡æ¯
   * @returns {Object} ç»Ÿè®¡ä¿¡æ¯
   */
  getStats() {
    return {
      memory: this.enableMemory ? this.memoryCache.getStats() : null,
      storage: this.enableStorage ? this.storageCache.getStorageInfo() : null
    }
  }
}

/**
 * ç¼“å­˜ç®¡ç†å™¨å·¥å‚
 */
class CacheManagerFactory {
  constructor() {
    this.caches = new Map()
  }

  /**
   * åˆ›å»ºæˆ–è·å–ç¼“å­˜å®ä¾‹
   * @param {string} name ç¼“å­˜åç§°
   * @param {Object} options é…ç½®é€‰é¡¹
   * @returns {MultiLayerCache} ç¼“å­˜å®ä¾‹
   */
  getCache(name, options = {}) {
    if (!this.caches.has(name)) {
      const cache = new MultiLayerCache({
        ...options,
        storagePrefix: `${name}_`
      })
      this.caches.set(name, cache)
    }
    return this.caches.get(name)
  }

  /**
   * æ¸…ç†æ‰€æœ‰ç¼“å­˜
   */
  cleanupAll() {
    let totalCleaned = 0
    for (const cache of this.caches.values()) {
      totalCleaned += cache.cleanup()
    }
    return totalCleaned
  }

  /**
   * è·å–æ‰€æœ‰ç¼“å­˜ç»Ÿè®¡
   * @returns {Object} ç»Ÿè®¡ä¿¡æ¯
   */
  getAllStats() {
    const stats = {}
    for (const [name, cache] of this.caches) {
      stats[name] = cache.getStats()
    }
    return stats
  }
}

// åˆ›å»ºå…¨å±€ç¼“å­˜ç®¡ç†å™¨å®ä¾‹
const cacheFactory = new CacheManagerFactory()

// é¢„å®šä¹‰çš„ç¼“å­˜å®ä¾‹
const audioCache = cacheFactory.getCache('audio', {
  memoryCapacity: 30,
  storageTTL: 24 * 60 * 60 * 1000 // 24å°æ—¶
})

const aiCache = cacheFactory.getCache('ai', {
  memoryCapacity: 20,
  storageTTL: 7 * 24 * 60 * 60 * 1000 // 7å¤©
})

// å®šæœŸæ¸…ç†ä»»åŠ¡
setInterval(() => {
  const cleaned = cacheFactory.cleanupAll()
  if (cleaned > 0) {
    console.log(`ğŸ—‘ï¸ å®šæœŸæ¸…ç†è¿‡æœŸç¼“å­˜ï¼Œæ¸…ç†æ•°é‡: ${cleaned}`)
  }
}, 60 * 60 * 1000) // æ¯å°æ—¶æ¸…ç†ä¸€æ¬¡

module.exports = {
  LRUCache,
  StorageCache,
  MultiLayerCache,
  CacheManagerFactory,
  cacheFactory,
  audioCache,
  aiCache
}
```

## å†’é™©åœ°å›¾é¡µé¢ (pages/adventure-map/adventure-map.js)

```javascript
/**
 * å†’é™©åœ°å›¾é¡µé¢ - æ˜¾ç¤ºå­¦ä¹ è¿›åº¦å’Œå…³å¡é€‰æ‹©
 */

const app = getApp()
const { dataManager } = require('../../utils/data-manager')
const { audioService } = require('../../utils/audio-service')

Page({
  data: {
    userProfile: null,
    levels: [],
    currentLevel: 1,
    maxLevel: 100,
    progressPercentage: 0,
    showLevelPreview: false,
    previewLevel: null,
    mapPath: null,
    canvasWidth: 0,
    canvasHeight: 0,
    animationTimer: null
  },

  /**
   * é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–
   */
  onLoad() {
    this.loadUserData()
    this.generateLevels()
    this.updateProgressDisplay()
  },

  /**
   * é¡µé¢æ˜¾ç¤ºæ—¶åˆ·æ–°æ•°æ®
   */
  onShow() {
    this.loadUserData()
    this.updateProgressDisplay()
  },

  /**
   * é¡µé¢å‡†å¤‡å®Œæˆååˆå§‹åŒ–åœ°å›¾
   */
  onReady() {
    this.initMapPath()
  },

  /**
   * åŠ è½½ç”¨æˆ·æ•°æ®
   */
  async loadUserData() {
    try {
      const profile = await dataManager.getUserProfile()
      this.setData({
        userProfile: profile,
        currentLevel: profile.currentLevel || 1
      })
    } catch (error) {
      console.error('åŠ è½½ç”¨æˆ·æ•°æ®å¤±è´¥:', error)
      wx.showToast({
        title: 'æ•°æ®åŠ è½½å¤±è´¥',
        icon: 'error'
      })
    }
  },

  /**
   * ç”Ÿæˆå…³å¡æ•°æ®
   */
  generateLevels() {
    const levels = []
    const maxLevel = this.getMaxLevel()
    
    for (let i = 1; i <= maxLevel; i++) {
      const level = {
        id: i,
        number: i,
        isUnlocked: i <= this.data.currentLevel,
        isCompleted: i < this.data.currentLevel,
        isCurrent: i === this.data.currentLevel,
        stars: this.getLevelStars(i),
        difficulty: this.getLevelDifficulty(i),
        wordCount: this.getLevelWordCount(i),
        position: this.calculateLevelPosition(i, maxLevel)
      }
      levels.push(level)
    }
    
    this.setData({ 
      levels,
      maxLevel
    })
  },

  /**
   * åŠ¨æ€è·å–æœ€å¤§å…³å¡æ•°
   * @returns {number} æœ€å¤§å…³å¡æ•°
   */
  getMaxLevel() {
    // æ ¹æ®ç”¨æˆ·ç­‰çº§å’Œè¿›åº¦åŠ¨æ€è°ƒæ•´
    const baseLevel = 50
    const userLevel = this.data.userProfile?.level || 1
    const bonusLevels = Math.floor(userLevel / 5) * 10
    return Math.min(baseLevel + bonusLevels, 200)
  },

  /**
   * è·å–å…³å¡æ˜Ÿçº§
   * @param {number} levelId å…³å¡ID
   * @returns {number} æ˜Ÿçº§æ•°é‡
   */
  getLevelStars(levelId) {
    const progress = this.data.userProfile?.levelProgress?.[levelId]
    if (!progress) return 0
    
    const { accuracy, speed, bonus } = progress
    let stars = 0
    
    if (accuracy >= 0.8) stars++
    if (speed >= 0.7) stars++
    if (bonus > 0) stars++
    
    return stars
  },

  /**
   * è·å–å…³å¡éš¾åº¦
   * @param {number} levelId å…³å¡ID
   * @returns {string} éš¾åº¦ç­‰çº§
   */
  getLevelDifficulty(levelId) {
    if (levelId <= 10) return 'easy'
    if (levelId <= 30) return 'medium'
    if (levelId <= 60) return 'hard'
    return 'expert'
  },

  /**
   * è·å–å…³å¡å•è¯æ•°é‡
   * @param {number} levelId å…³å¡ID
   * @returns {number} å•è¯æ•°é‡
   */
  getLevelWordCount(levelId) {
    const difficulty = this.getLevelDifficulty(levelId)
    const baseCounts = {
      easy: 5,
      medium: 8,
      hard: 12,
      expert: 15
    }
    
    const baseCount = baseCounts[difficulty]
    const variation = Math.floor(Math.random() * 3) - 1 // -1, 0, 1
    return Math.max(3, baseCount + variation)
  },

  /**
   * è®¡ç®—å…³å¡åœ¨åœ°å›¾ä¸Šçš„ä½ç½®
   * @param {number} levelId å…³å¡ID
   * @param {number} maxLevel æœ€å¤§å…³å¡æ•°
   * @returns {Object} ä½ç½®åæ ‡
   */
  calculateLevelPosition(levelId, maxLevel) {
    const mapWidth = 750 // rpx
    const mapHeight = 1200 // rpx
    const padding = 50
    
    // è›‡å½¢è·¯å¾„ç®—æ³•
    const cols = 5
    const rows = Math.ceil(maxLevel / cols)
    
    const row = Math.floor((levelId - 1) / cols)
    let col = (levelId - 1) % cols
    
    // å¥‡æ•°è¡Œåå‘æ’åˆ—
    if (row % 2 === 1) {
      col = cols - 1 - col
    }
    
    const x = padding + (col * (mapWidth - 2 * padding)) / (cols - 1)
    const y = padding + (row * (mapHeight - 2 * padding)) / (rows - 1)
    
    return { x, y }
  },

  /**
   * æ‰¹é‡è·å–å…³å¡æ•°æ®
   * @param {Array} levelIds å…³å¡IDæ•°ç»„
   * @returns {Promise<Array>} å…³å¡æ•°æ®æ•°ç»„
   */
  async batchGetLevelData(levelIds) {
    try {
      const promises = levelIds.map(id => dataManager.getLevelData(id))
      const results = await Promise.allSettled(promises)
      
      return results.map((result, index) => {
        if (result.status === 'fulfilled') {
          return result.value
        } else {
          console.warn(`è·å–å…³å¡ ${levelIds[index]} æ•°æ®å¤±è´¥:`, result.reason)
          return null
        }
      }).filter(Boolean)
    } catch (error) {
      console.error('æ‰¹é‡è·å–å…³å¡æ•°æ®å¤±è´¥:', error)
      return []
    }
  },

  /**
   * ç›‘å¬æ•°æ®æ›´æ–°
   */
  setupDataListeners() {
    // ç›‘å¬ç”¨æˆ·æ¡£æ¡ˆæ›´æ–°
    dataManager.on('userProfileUpdated', (profile) => {
      this.setData({ userProfile: profile })
      this.generateLevels()
      this.updateProgressDisplay()
    })
    
    // ç›‘å¬å…³å¡å®Œæˆ
    dataManager.on('levelCompleted', (levelData) => {
      this.generateLevels()
      this.updateProgressDisplay()
      this.playLevelCompleteAnimation(levelData.levelId)
    })
  },

  /**
   * æ›´æ–°å­¦ä¹ è¿›åº¦æ˜¾ç¤º
   */
  updateProgressDisplay() {
    const { currentLevel, maxLevel } = this.data
    const progressPercentage = Math.round((currentLevel / maxLevel) * 100)
    
    this.setData({ progressPercentage })
  },

  /**
   * æ’­æ”¾å…³å¡åŠ¨ç”»
   * @param {number} levelId å…³å¡ID
   */
  playLevelCompleteAnimation(levelId) {
    const animation = wx.createAnimation({
      duration: 1000,
      timingFunction: 'ease-in-out'
    })
    
    animation.scale(1.2).step()
    animation.scale(1).step()
    
    this.setData({
      [`levels[${levelId - 1}].animation`]: animation.export()
    })
    
    // æ’­æ”¾å®ŒæˆéŸ³æ•ˆ
    audioService.playSound('level_complete')
  },

  /**
   * å…³å¡ç‚¹å‡»äº‹ä»¶
   * @param {Object} e äº‹ä»¶å¯¹è±¡
   */
  onLevelTap(e) {
    const { level } = e.currentTarget.dataset
    
    if (!level.isUnlocked) {
      wx.showToast({
        title: 'å…³å¡æœªè§£é”',
        icon: 'none'
      })
      return
    }
    
    // æ’­æ”¾ç‚¹å‡»éŸ³æ•ˆ
    audioService.playSound('button_click')
    
    // æ˜¾ç¤ºå…³å¡é¢„è§ˆ
    this.showLevelPreview(level)
  },

  /**
   * æ˜¾ç¤ºå…³å¡é¢„è§ˆ
   * @param {Object} level å…³å¡æ•°æ®
   */
  async showLevelPreview(level) {
    try {
      // è·å–å…³å¡è¯¦ç»†æ•°æ®
      const levelData = await dataManager.getLevelData(level.id)
      
      this.setData({
        showLevelPreview: true,
        previewLevel: {
          ...level,
          ...levelData,
          estimatedTime: this.estimateCompletionTime(levelData),
          rewards: this.calculateLevelRewards(level.id)
        }
      })
    } catch (error) {
      console.error('è·å–å…³å¡é¢„è§ˆæ•°æ®å¤±è´¥:', error)
      wx.showToast({
        title: 'åŠ è½½å¤±è´¥',
        icon: 'error'
      })
    }
  },

  /**
   * ä¼°ç®—å®Œæˆæ—¶é—´
   * @param {Object} levelData å…³å¡æ•°æ®
   * @returns {number} é¢„ä¼°æ—¶é—´ï¼ˆåˆ†é’Ÿï¼‰
   */
  estimateCompletionTime(levelData) {
    const wordCount = levelData.words?.length || 10
    const avgTimePerWord = 15 // ç§’
    const totalSeconds = wordCount * avgTimePerWord
    return Math.ceil(totalSeconds / 60)
  },

  /**
   * è®¡ç®—å…³å¡å¥–åŠ±
   * @param {number} levelId å…³å¡ID
   * @returns {Object} å¥–åŠ±ä¿¡æ¯
   */
  calculateLevelRewards(levelId) {
    const baseExp = 50
    const baseCoins = 20
    
    const difficulty = this.getLevelDifficulty(levelId)
    const multipliers = {
      easy: 1,
      medium: 1.5,
      hard: 2,
      expert: 3
    }
    
    const multiplier = multipliers[difficulty]
    
    return {
      experience: Math.floor(baseExp * multiplier),
      coins: Math.floor(baseCoins * multiplier),
      items: this.generateRandomRewards(levelId)
    }
  },

  /**
   * ç”Ÿæˆéšæœºå¥–åŠ±
   * @param {number} levelId å…³å¡ID
   * @returns {Array} å¥–åŠ±ç‰©å“åˆ—è¡¨
   */
  generateRandomRewards(levelId) {
    const rewards = []
    const rewardPool = [
      { type: 'hint', name: 'æç¤ºå¡', probability: 0.3 },
      { type: 'time', name: 'æ—¶é—´å»¶é•¿å¡', probability: 0.2 },
      { type: 'double', name: 'åŒå€ç§¯åˆ†å¡', probability: 0.15 },
      { type: 'skip', name: 'è·³è¿‡å¡', probability: 0.1 }
    ]
    
    rewardPool.forEach(reward => {
      if (Math.random() < reward.probability) {
        rewards.push(reward)
      }
    })
    
    return rewards
  },

  /**
   * å…³é—­é¢„è§ˆ
   */
  closePreview() {
    this.setData({
      showLevelPreview: false,
      previewLevel: null
    })
  },

  /**
   * å¼€å§‹å…³å¡
   */
  startLevel() {
    const { previewLevel } = this.data
    if (!previewLevel) return
    
    // æ’­æ”¾å¼€å§‹éŸ³æ•ˆ
    audioService.playSound('game_start')
    
    // è·³è½¬åˆ°å­¦ä¹ é¡µé¢
    wx.navigateTo({
      url: `/pages/word-learning/word-learning?levelId=${previewLevel.id}`
    })
  },

  /**
   * ç»§ç»­å†’é™©ï¼ˆè·³è½¬åˆ°å½“å‰å…³å¡ï¼‰
   */
  continueAdventure() {
    const { currentLevel } = this.data
    
    wx.navigateTo({
      url: `/pages/word-learning/word-learning?levelId=${currentLevel}`
    })
  },

  /**
   * æ‰“å¼€è®¾ç½®
   */
  openSettings() {
    wx.navigateTo({
      url: '/pages/settings/settings'
    })
  },

  /**
   * é¢„è§ˆé®ç½©ç‚¹å‡»
   */
  onPreviewMaskTap() {
    this.closePreview()
  },

  /**
   * åˆå§‹åŒ–åœ°å›¾è·¯å¾„
   */
  initMapPath() {
    const query = wx.createSelectorQuery()
    query.select('#map-canvas')
      .fields({ node: true, size: true })
      .exec((res) => {
        if (res[0]) {
          const canvas = res[0].node
          const ctx = canvas.getContext('2d')
          
          const dpr = wx.getSystemInfoSync().pixelRatio
          canvas.width = res[0].width * dpr
          canvas.height = res[0].height * dpr
          ctx.scale(dpr, dpr)
          
          this.setData({
            canvasWidth: res[0].width,
            canvasHeight: res[0].height
          })
          
          this.drawMapPath(ctx)
        }
      })
  },

  /**
   * ç»˜åˆ¶åœ°å›¾è·¯å¾„
   * @param {CanvasRenderingContext2D} ctx Canvasä¸Šä¸‹æ–‡
   */
  drawMapPath(ctx) {
    const { levels } = this.data
    if (levels.length < 2) return
    
    ctx.strokeStyle = '#4CAF50'
    ctx.lineWidth = 3
    ctx.lineCap = 'round'
    ctx.lineJoin = 'round'
    
    ctx.beginPath()
    
    // ç»˜åˆ¶è¿æ¥çº¿
    for (let i = 0; i < levels.length - 1; i++) {
      const current = levels[i]
      const next = levels[i + 1]
      
      if (i === 0) {
        ctx.moveTo(current.position.x, current.position.y)
      }
      
      // ä½¿ç”¨è´å¡å°”æ›²çº¿åˆ›å»ºå¹³æ»‘è·¯å¾„
      const midX = (current.position.x + next.position.x) / 2
      const midY = (current.position.y + next.position.y) / 2
      
      ctx.quadraticCurveTo(
        current.position.x,
        current.position.y,
        midX,
        midY
      )
    }
    
    ctx.stroke()
    
    // ç»˜åˆ¶å…³å¡ç‚¹
    levels.forEach(level => {
      this.drawLevelPoint(ctx, level)
    })
  },

  /**
   * ç»˜åˆ¶å…³å¡ç‚¹
   * @param {CanvasRenderingContext2D} ctx Canvasä¸Šä¸‹æ–‡
   * @param {Object} level å…³å¡æ•°æ®
   */
  drawLevelPoint(ctx, level) {
    const { x, y } = level.position
    const radius = 15
    
    // è®¾ç½®é¢œè‰²
    if (level.isCompleted) {
      ctx.fillStyle = '#4CAF50'
    } else if (level.isCurrent) {
      ctx.fillStyle = '#FF9800'
    } else if (level.isUnlocked) {
      ctx.fillStyle = '#2196F3'
    } else {
      ctx.fillStyle = '#BDBDBD'
    }
    
    // ç»˜åˆ¶åœ†ç‚¹
    ctx.beginPath()
    ctx.arc(x, y, radius, 0, 2 * Math.PI)
    ctx.fill()
    
    // ç»˜åˆ¶è¾¹æ¡†
    ctx.strokeStyle = '#FFFFFF'
    ctx.lineWidth = 2
    ctx.stroke()
    
    // ç»˜åˆ¶å…³å¡å·
    ctx.fillStyle = '#FFFFFF'
    ctx.font = '12px Arial'
    ctx.textAlign = 'center'
    ctx.textBaseline = 'middle'
    ctx.fillText(level.number.toString(), x, y)
  },

  /**
   * æ‰“å¼€ç»Ÿè®¡é¡µé¢
   */
  openStatistics() {
    wx.navigateTo({
      url: '/pages/statistics/statistics'
    })
  },

  /**
   * æ¯æ—¥æŒ‘æˆ˜
   */
  openDailyChallenge() {
    wx.navigateTo({
      url: '/pages/daily-challenge/daily-challenge'
    })
  },

  /**
   * æ‰“å¼€å•†åº—
   */
  openShop() {
    wx.navigateTo({
      url: '/pages/shop/shop'
    })
  },

  /**
   * é¡µé¢å¸è½½æ—¶æ¸…ç†
   */
  onUnload() {
    if (this.data.animationTimer) {
      clearInterval(this.data.animationTimer)
    }
    
    // ç§»é™¤æ•°æ®ç›‘å¬å™¨
    dataManager.off('userProfileUpdated')
    dataManager.off('levelCompleted')
  }
})
```

// utils/data-manager.js
// SpellWell æ•°æ®ç®¡ç†ä¸­å¿ƒ - ç»Ÿä¸€ç®¡ç†å…³å¡æ•°æ®ã€ç”¨æˆ·è¿›åº¦å’Œç¼“å­˜

const util = require('./util.js')

/**
 * æ•°æ®ç®¡ç†ä¸­å¿ƒ
 * è´Ÿè´£ç»Ÿä¸€ç®¡ç†å…³å¡æ•°æ®ã€ç”¨æˆ·è¿›åº¦ã€ç¼“å­˜ç­‰æ ¸å¿ƒæ•°æ®
 */
class DataManager {
  constructor() {
    this.cache = new Map()
    this.cacheTimeout = 5 * 60 * 1000 // 5åˆ†é’Ÿç¼“å­˜
    this.storageKeys = {
      userProfile: 'wordHero_profile',
      learningHistory: 'wordHero_learningHistory',
      currentLevel: 'wordHero_currentLevel',
      backup: 'wordHero_profile_backup',
      settings: 'wordHero_settings'
    }
    
    this.init()
  }

  init() {
    // åˆå§‹åŒ–æ—¶é¢„åŠ è½½å¸¸ç”¨æ•°æ®
    this.preloadCommonData()
    
    // å¯åŠ¨è‡ªåŠ¨å¤‡ä»½
    this.startAutoBackup()
  }

  /**
   * è·å–å…³å¡æ•°æ®ï¼ˆå¸¦ç¼“å­˜ï¼‰
   * @param {number} level - å…³å¡ç¼–å·
   * @returns {Object} å…³å¡æ•°æ®
   */
  getLevelData(level) {
    const cacheKey = `level_${level}`
    
    // æ£€æŸ¥ç¼“å­˜
    if (this.cache.has(cacheKey)) {
      const cached = this.cache.get(cacheKey)
      if (Date.now() - cached.timestamp < this.cacheTimeout) {
        return cached.data
      }
    }

    // è·å–æ–°æ•°æ®
    const wordLibrary = require('./word-library.js')
    const levelData = wordLibrary.getLevelWords(level)
    
    // ç¼“å­˜æ•°æ®
    this.cache.set(cacheKey, {
      data: levelData,
      timestamp: Date.now()
    })
    
    return levelData
  }

  /**
   * æ‰¹é‡è·å–å…³å¡æ•°æ®
   * @param {Array} levels - å…³å¡ç¼–å·æ•°ç»„
   * @returns {Array} å…³å¡æ•°æ®æ•°ç»„
   */
  getBatchLevelData(levels) {
    return levels.map(level => this.getLevelData(level))
  }

  /**
   * è·å–ç”¨æˆ·æ¡£æ¡ˆ
   * @returns {Object} ç”¨æˆ·æ¡£æ¡ˆæ•°æ®
   */
  getUserProfile() {
    try {
      const profile = util.storage.get(this.storageKeys.userProfile)
      if (!profile) {
        return this.createDefaultProfile()
      }
      
      // æ•°æ®è¿ç§»å’Œæ ¡éªŒ
      return this.validateAndMigrateProfile(profile)
    } catch (error) {
      console.error('è·å–ç”¨æˆ·æ¡£æ¡ˆå¤±è´¥:', error)
      return this.createDefaultProfile()
    }
  }

  /**
   * åˆ›å»ºé»˜è®¤ç”¨æˆ·æ¡£æ¡ˆ
   * @returns {Object} é»˜è®¤æ¡£æ¡ˆ
   */
  createDefaultProfile() {
    const defaultProfile = {
      userId: this.generateUserId(),
      version: '2.0',
      createdAt: new Date().toISOString(),
      lastUpdated: new Date().toISOString(),
      
      // åŸºæœ¬ä¿¡æ¯ï¼ˆå…¼å®¹æ€§ï¼šä¿æŒä¸app.jsä¸€è‡´ï¼‰
      nickname: 'å°è¶…äºº',
      avatar: 'ğŸ“',
      grade: 'primary',
      currentLevel: 1,
      totalWordsLearned: 0,
      streak: 0,
      lastStudyDate: null,
      
      // è¯¦ç»†å­¦ä¹ è¿›åº¦
      progress: {
        currentLevel: 1,
        completedLevels: [],
        levelProgress: {},
        totalScore: 0,
        globalStreak: 0,
        maxStreak: 0
      },
      
      // ç»Ÿè®¡æ•°æ®
      stats: {
        totalWords: 0,
        totalCorrect: 0,
        totalAttempts: 0,
        accuracy: 0,
        totalStudyTime: 0,
        lastStudyDate: null,
        consecutiveDays: 0
      },
      
      // æ¯æ—¥è®°å½•
      dailyRecords: {},
      
      // æˆå°±ç³»ç»Ÿ
      achievements: [],
      
      // å­¦ä¹ åå¥½
      preferences: {
        soundEnabled: true,
        vibrationEnabled: true,
        autoPlay: false,
        difficulty: 'normal'
      }
    }
    
    this.saveUserProfile(defaultProfile)
    return defaultProfile
  }

  /**
   * ä¿å­˜ç”¨æˆ·æ¡£æ¡ˆï¼ˆåŸå­æ€§æ“ä½œï¼‰
   * @param {Object} profile - ç”¨æˆ·æ¡£æ¡ˆ
   * @param {Object} options - ä¿å­˜é€‰é¡¹
   */
  async saveUserProfile(profile, options = {}) {
    try {
      // æ•°æ®æ ¡éªŒ
      if (!this.validateProfile(profile)) {
        throw new Error('ç”¨æˆ·æ¡£æ¡ˆæ•°æ®æ ¼å¼é”™è¯¯')
      }

      // å¤‡ä»½å½“å‰æ•°æ®
      if (!options.skipBackup) {
        const currentProfile = util.storage.get(this.storageKeys.userProfile)
        if (currentProfile) {
          util.storage.set(this.storageKeys.backup, currentProfile)
        }
      }

      // æ›´æ–°æ—¶é—´æˆ³
      profile.lastUpdated = new Date().toISOString()
      
      // ä¿å­˜æ•°æ®
      const success = util.storage.set(this.storageKeys.userProfile, profile)
      
      if (!success) {
        throw new Error('å­˜å‚¨å¤±è´¥')
      }

      // æ¸…é™¤ç›¸å…³ç¼“å­˜
      this.clearUserCache()
      
      // è§¦å‘æ•°æ®æ›´æ–°äº‹ä»¶
      this.emitDataUpdate('profile', profile)
      
      return profile
    } catch (error) {
      console.error('ä¿å­˜ç”¨æˆ·æ¡£æ¡ˆå¤±è´¥:', error)
      
      // å°è¯•æ¢å¤å¤‡ä»½
      if (!options.skipRestore) {
        this.restoreFromBackup()
      }
      
      throw error
    }
  }

  /**
   * æ›´æ–°å­¦ä¹ è¿›åº¦
   * @param {Object} progressData - è¿›åº¦æ•°æ®
   */
  updateLearningProgress(progressData) {
    const profile = this.getUserProfile()
    
    // æ›´æ–°å…³å¡è¿›åº¦
    if (progressData.level && progressData.completed) {
      const level = progressData.level
      
      // æ ‡è®°å…³å¡å®Œæˆ
      if (!profile.progress.completedLevels.includes(level)) {
        profile.progress.completedLevels.push(level)
      }
      
      // æ›´æ–°å½“å‰å…³å¡
      profile.progress.currentLevel = Math.max(
        profile.progress.currentLevel,
        level + 1
      )
      
      // è®°å½•å…³å¡è¯¦ç»†è¿›åº¦
      profile.progress.levelProgress[level] = {
        completed: true,
        accuracy: progressData.accuracy || 0,
        timeSpent: progressData.timeSpent || 0,
        completedAt: new Date().toISOString(),
        stars: this.calculateStars(progressData.accuracy)
      }
    }
    
    // æ›´æ–°ç»Ÿè®¡æ•°æ®
    if (progressData.stats) {
      const stats = progressData.stats
      profile.stats.totalWords += stats.totalWords || 0
      profile.stats.totalCorrect += stats.correct || 0
      profile.stats.totalAttempts += stats.total || 0
      profile.stats.accuracy = profile.stats.totalAttempts > 0 ? 
        Math.round((profile.stats.totalCorrect / profile.stats.totalAttempts) * 100) : 0
      profile.stats.lastStudyDate = new Date().toISOString()
    }
    
    // æ›´æ–°æ¯æ—¥è®°å½•
    this.updateDailyRecord(profile, progressData)
    
    // ä¿å­˜æ›´æ–°åçš„æ¡£æ¡ˆ
    return this.saveUserProfile(profile)
  }

  /**
   * æ›´æ–°æ¯æ—¥å­¦ä¹ è®°å½•
   * @param {Object} profile - ç”¨æˆ·æ¡£æ¡ˆ
   * @param {Object} progressData - è¿›åº¦æ•°æ®
   */
  updateDailyRecord(profile, progressData) {
    const today = this.formatDate(new Date(), 'YYYY-MM-DD')
    
    if (!profile.dailyRecords[today]) {
      profile.dailyRecords[today] = {
        words: 0,
        accuracy: 0,
        studyTime: 0,
        levels: [],
        sessions: 0
      }
    }
    
    const todayRecord = profile.dailyRecords[today]
    
    if (progressData.wordsCount) {
      todayRecord.words += progressData.wordsCount
    }
    
    if (progressData.timeSpent) {
      todayRecord.studyTime += progressData.timeSpent
    }
    
    if (progressData.level && !todayRecord.levels.includes(progressData.level)) {
      todayRecord.levels.push(progressData.level)
    }
    
    todayRecord.sessions += 1
    
    // è®¡ç®—ä»Šæ—¥å‡†ç¡®ç‡
    if (progressData.accuracy) {
      todayRecord.accuracy = Math.round(
        (todayRecord.accuracy * (todayRecord.sessions - 1) + progressData.accuracy) / todayRecord.sessions
      )
    }
  }

  /**
   * é¢„åŠ è½½å¸¸ç”¨æ•°æ®
   */
  preloadCommonData() {
    try {
      // é¢„åŠ è½½å‰3ä¸ªå…³å¡çš„æ•°æ®
      for (let i = 1; i <= 3; i++) {
        this.getLevelData(i)
      }
      
      // é¢„åŠ è½½ç”¨æˆ·æ¡£æ¡ˆ
      this.getUserProfile()
      
    } catch (error) {
      console.error('é¢„åŠ è½½æ•°æ®å¤±è´¥:', error)
    }
  }

  /**
   * æ¸…é™¤ç¼“å­˜
   * @param {string} type - ç¼“å­˜ç±»å‹
   */
  clearCache(type) {
    if (type === 'all') {
      this.cache.clear()
    } else if (type === 'level') {
      for (const key of this.cache.keys()) {
        if (key.startsWith('level_')) {
          this.cache.delete(key)
        }
      }
    } else if (type === 'user') {
      this.clearUserCache()
    }
  }

  /**
   * æ¸…é™¤ç”¨æˆ·ç›¸å…³ç¼“å­˜
   */
  clearUserCache() {
    for (const key of this.cache.keys()) {
      if (key.startsWith('user_') || key.startsWith('profile_')) {
        this.cache.delete(key)
      }
    }
  }

  /**
   * æ•°æ®æ ¡éªŒ
   * @param {Object} profile - ç”¨æˆ·æ¡£æ¡ˆ
   * @returns {boolean} æ˜¯å¦æœ‰æ•ˆ
   */
  validateProfile(profile) {
    try {
      // æ£€æŸ¥å¿…è¦å­—æ®µ
      if (!profile || typeof profile !== 'object') {
        console.warn('æ¡£æ¡ˆä¸æ˜¯æœ‰æ•ˆå¯¹è±¡')
        return false
      }
      
      if (!profile.userId) {
        console.warn('ç¼ºå°‘ç”¨æˆ·ID')
        return false
      }
      
      if (!profile.progress || typeof profile.progress !== 'object') {
        console.warn('ç¼ºå°‘è¿›åº¦å¯¹è±¡')
        return false
      }
      
      if (!profile.stats || typeof profile.stats !== 'object') {
        console.warn('ç¼ºå°‘ç»Ÿè®¡å¯¹è±¡')
        return false
      }
      
      // æ£€æŸ¥æ•°æ®ç±»å‹
      if (typeof profile.progress.currentLevel !== 'number') {
        console.warn('å½“å‰å…³å¡ä¸æ˜¯æ•°å­—ç±»å‹:', typeof profile.progress.currentLevel)
        return false
      }
      
      if (!Array.isArray(profile.progress.completedLevels)) {
        console.warn('å·²å®Œæˆå…³å¡ä¸æ˜¯æ•°ç»„ç±»å‹:', typeof profile.progress.completedLevels)
        return false
      }
      
      return true
    } catch (error) {
      console.error('æ•°æ®æ ¡éªŒå‡ºé”™:', error)
      return false
    }
  }

  /**
   * æ•°æ®è¿ç§»å’Œå…¼å®¹æ€§å¤„ç†
   * @param {Object} profile - åŸå§‹æ¡£æ¡ˆ
   * @returns {Object} è¿ç§»åçš„æ¡£æ¡ˆ
   */
  validateAndMigrateProfile(profile) {
    // ç‰ˆæœ¬è¿ç§»
    if (!profile.version || profile.version === '1.0') {
      profile = this.migrateFromV1(profile)
    }
    
    // è¡¥å……ç¼ºå¤±å­—æ®µ
    if (!profile.preferences) {
      profile.preferences = {
        soundEnabled: true,
        vibrationEnabled: true,
        autoPlay: false,
        difficulty: 'normal'
      }
    }
    
    if (!profile.achievements) {
      profile.achievements = []
    }
    
    return profile
  }

  /**
   * ä»V1.0ç‰ˆæœ¬è¿ç§»æ•°æ®
   * @param {Object} oldProfile - V1.0æ¡£æ¡ˆ
   * @returns {Object} V2.0æ¡£æ¡ˆ
   */
  migrateFromV1(oldProfile) {
    try {
      const newProfile = this.createDefaultProfile()
      
      // å®‰å…¨åœ°è¿ç§»åŸºæœ¬ä¿¡æ¯ï¼ˆå…¼å®¹ä¸¤ç§ç»“æ„ï¼‰
      let currentLevel = 1
      
      if (oldProfile.currentLevel && typeof oldProfile.currentLevel === 'number') {
        currentLevel = oldProfile.currentLevel
      } else if (oldProfile.progress && 
                 oldProfile.progress.currentLevel && 
                 typeof oldProfile.progress.currentLevel === 'number') {
        currentLevel = oldProfile.progress.currentLevel
      }
      
      // ç¡®ä¿å…³å¡æ•°å€¼åˆç†
      currentLevel = Math.max(1, Math.min(currentLevel, 35))
      
      newProfile.currentLevel = currentLevel
      newProfile.progress.currentLevel = currentLevel
      
      // å®‰å…¨åœ°è¿ç§»å·²å®Œæˆå…³å¡
      if (oldProfile.progress && 
          oldProfile.progress.completedLevels && 
          Array.isArray(oldProfile.progress.completedLevels)) {
        newProfile.progress.completedLevels = [...oldProfile.progress.completedLevels]
      } else {
        // æ ¹æ®å½“å‰å…³å¡æ¨ç®—å·²å®Œæˆå…³å¡
        newProfile.progress.completedLevels = []
        for (let i = 1; i < currentLevel; i++) {
          newProfile.progress.completedLevels.push(i)
        }
      }
      
      // å®‰å…¨åœ°è¿ç§»å…¶ä»–åŸºæœ¬ä¿¡æ¯
      if (oldProfile.nickname && typeof oldProfile.nickname === 'string') {
        newProfile.nickname = oldProfile.nickname
      }
      if (oldProfile.avatar && typeof oldProfile.avatar === 'string') {
        newProfile.avatar = oldProfile.avatar
      }
      if (oldProfile.grade && typeof oldProfile.grade === 'string') {
        newProfile.grade = oldProfile.grade
      }
      if (oldProfile.totalWordsLearned && typeof oldProfile.totalWordsLearned === 'number') {
        newProfile.totalWordsLearned = oldProfile.totalWordsLearned
      }
      if (oldProfile.streak && typeof oldProfile.streak === 'number') {
        newProfile.streak = oldProfile.streak
      }
      if (oldProfile.lastStudyDate && typeof oldProfile.lastStudyDate === 'string') {
        newProfile.lastStudyDate = oldProfile.lastStudyDate
      }
      
      // å®‰å…¨åœ°è¿ç§»ç»Ÿè®¡æ•°æ®
      if (oldProfile.stats && typeof oldProfile.stats === 'object') {
        if (typeof oldProfile.stats.totalWords === 'number') {
          newProfile.stats.totalWords = oldProfile.stats.totalWords
        }
        if (typeof oldProfile.stats.accuracy === 'number') {
          newProfile.stats.accuracy = oldProfile.stats.accuracy
        }
        if (typeof oldProfile.stats.totalCorrect === 'number') {
          newProfile.stats.totalCorrect = oldProfile.stats.totalCorrect
        }
        if (typeof oldProfile.stats.totalAttempts === 'number') {
          newProfile.stats.totalAttempts = oldProfile.stats.totalAttempts
        }
      }
      
      // ä¿æŒåŸæœ‰çš„ç”¨æˆ·IDå’Œåˆ›å»ºæ—¶é—´
      if (oldProfile.userId && typeof oldProfile.userId === 'string') {
        newProfile.userId = oldProfile.userId
      }
      if (oldProfile.createdAt && typeof oldProfile.createdAt === 'string') {
        newProfile.createdAt = oldProfile.createdAt
      }
      
      newProfile.version = '2.0'
      
      console.log('æ•°æ®è¿ç§»å®Œæˆ:', {
        currentLevel: newProfile.progress.currentLevel,
        completedLevels: newProfile.progress.completedLevels
      })
      
      return newProfile
    } catch (error) {
      console.error('æ•°æ®è¿ç§»å¤±è´¥:', error)
      // å¦‚æœè¿ç§»å¤±è´¥ï¼Œè¿”å›é»˜è®¤æ¡£æ¡ˆ
      return this.createDefaultProfile()
    }
  }

  /**
   * è‡ªåŠ¨å¤‡ä»½æœºåˆ¶
   */
  startAutoBackup() {
    // æ¯24å°æ—¶è‡ªåŠ¨å¤‡ä»½ä¸€æ¬¡
    const backupInterval = 24 * 60 * 60 * 1000
    
    setInterval(() => {
      this.createBackup()
    }, backupInterval)
    
    // åº”ç”¨å¯åŠ¨æ—¶ä¹Ÿå¤‡ä»½ä¸€æ¬¡
    setTimeout(() => {
      this.createBackup()
    }, 5000)
  }

  /**
   * åˆ›å»ºæ•°æ®å¤‡ä»½
   */
  createBackup() {
    try {
      const profile = util.storage.get(this.storageKeys.userProfile)
      if (!profile) return
      
      const backup = {
        timestamp: Date.now(),
        data: profile,
        version: profile.version || '1.0'
      }
      
      util.storage.set(this.storageKeys.backup, backup)
      console.log('è‡ªåŠ¨å¤‡ä»½å®Œæˆ')
    } catch (error) {
      console.error('è‡ªåŠ¨å¤‡ä»½å¤±è´¥:', error)
    }
  }

  /**
   * ä»å¤‡ä»½æ¢å¤æ•°æ®
   */
  restoreFromBackup() {
    try {
      const backup = util.storage.get(this.storageKeys.backup)
      if (!backup || !backup.data) return false
      
      util.storage.set(this.storageKeys.userProfile, backup.data)
      this.clearCache('all')
      
      console.log('ä»å¤‡ä»½æ¢å¤æ•°æ®æˆåŠŸ')
      return true
    } catch (error) {
      console.error('ä»å¤‡ä»½æ¢å¤å¤±è´¥:', error)
      return false
    }
  }

  /**
   * è§¦å‘æ•°æ®æ›´æ–°äº‹ä»¶ï¼ˆå®‰å…¨ç‰ˆæœ¬ï¼‰
   * @param {string} type - äº‹ä»¶ç±»å‹
   * @param {*} data - äº‹ä»¶æ•°æ®
   */
  emitDataUpdate(type, data) {
    try {
      // æ£€æŸ¥æ˜¯å¦åœ¨å¾®ä¿¡å°ç¨‹åºç¯å¢ƒä¸­
      if (typeof getApp !== 'function') {
        console.warn('getAppå‡½æ•°ä¸å¯ç”¨ï¼Œè·³è¿‡æ•°æ®æ›´æ–°äº‹ä»¶')
        return
      }

      let app = null
      
      try {
        app = getApp()
      } catch (appError) {
        console.warn('è·å–appå®ä¾‹å¤±è´¥:', appError.message)
        return
      }
      
      // å®‰å…¨æ£€æŸ¥appå¯¹è±¡
      if (!app || typeof app !== 'object') {
        console.warn('appå¯¹è±¡æœªåˆå§‹åŒ–æˆ–æ— æ•ˆï¼Œè·³è¿‡æ•°æ®æ›´æ–°äº‹ä»¶')
        return
      }

      // æ£€æŸ¥onDataUpdateå±æ€§æ˜¯å¦å­˜åœ¨ä¸”ä¸ºå‡½æ•°
      if (app.hasOwnProperty('onDataUpdate') && typeof app.onDataUpdate === 'function') {
        console.log(`è§¦å‘æ•°æ®æ›´æ–°äº‹ä»¶: ${type}`)
        try {
          app.onDataUpdate(type, data)
        } catch (callError) {
          console.error('è°ƒç”¨app.onDataUpdateæ—¶å‘ç”Ÿé”™è¯¯:', callError)
        }
      } else {
        console.log(`app.onDataUpdateæ–¹æ³•ä¸å­˜åœ¨æˆ–ä¸æ˜¯å‡½æ•°ï¼Œäº‹ä»¶ç±»å‹: ${type}`)
        // å¦‚æœonDataUpdateä¸å­˜åœ¨ï¼Œå¯èƒ½appè¿˜åœ¨åˆå§‹åŒ–ä¸­ï¼Œç¨åé‡è¯•
        setTimeout(() => {
          this.retryEmitDataUpdate(type, data, 1)
        }, 100)
      }
      
    } catch (error) {
      console.error('è§¦å‘æ•°æ®æ›´æ–°äº‹ä»¶æ—¶å‘ç”Ÿé”™è¯¯:', error)
      // å³ä½¿äº‹ä»¶è§¦å‘å¤±è´¥ï¼Œä¹Ÿä¸åº”è¯¥å½±å“ä¸»è¦åŠŸèƒ½
    }
  }

  /**
   * é‡è¯•è§¦å‘æ•°æ®æ›´æ–°äº‹ä»¶
   * @param {string} type - äº‹ä»¶ç±»å‹
   * @param {*} data - äº‹ä»¶æ•°æ®
   * @param {number} retryCount - é‡è¯•æ¬¡æ•°
   */
  retryEmitDataUpdate(type, data, retryCount) {
    if (retryCount > 3) {
      console.warn(`æ•°æ®æ›´æ–°äº‹ä»¶é‡è¯•å¤±è´¥ï¼Œæ”¾å¼ƒé‡è¯•: ${type}`)
      return
    }

    try {
      if (typeof getApp === 'function') {
        const app = getApp()
        if (app && typeof app.onDataUpdate === 'function') {
          console.log(`é‡è¯•è§¦å‘æ•°æ®æ›´æ–°äº‹ä»¶æˆåŠŸ: ${type}, é‡è¯•æ¬¡æ•°: ${retryCount}`)
          app.onDataUpdate(type, data)
          return
        }
      }
      
      // ç»§ç»­é‡è¯•
      setTimeout(() => {
        this.retryEmitDataUpdate(type, data, retryCount + 1)
      }, 200)
      
    } catch (error) {
      console.error(`é‡è¯•è§¦å‘æ•°æ®æ›´æ–°äº‹ä»¶å¤±è´¥: ${retryCount}`, error)
    }
  }

  /**
   * è®¡ç®—å…³å¡æ˜Ÿçº§
   * @param {number} accuracy - å‡†ç¡®ç‡
   * @returns {number} æ˜Ÿçº§(1-3)
   */
  calculateStars(accuracy) {
    if (accuracy >= 95) return 3
    if (accuracy >= 85) return 2
    return 1
  }

  /**
   * ç”Ÿæˆç”¨æˆ·ID
   * @returns {string} ç”¨æˆ·ID
   */
  generateUserId() {
    return `user_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  }

  /**
   * è®°å½•å•è¯å­¦ä¹ è¿›åº¦
   * @param {string} word - å•è¯
   * @param {Object} progress - è¿›åº¦æ•°æ®
   * @returns {boolean} æ˜¯å¦æˆåŠŸ
   */
  recordWordProgress(word, progress) {
    try {
      const key = `word_progress_${word}`
      const progressData = {
        word,
        success: progress.success,
        timeTaken: progress.timeTaken,
        sessionId: progress.sessionId,
        timestamp: new Date().toISOString()
      }
      
      util.storage.set(key, progressData)
      
      // æ›´æ–°ç”¨æˆ·æ€»ä½“ç»Ÿè®¡
      this.updateUserStats(progress.success)
      
      console.log(`ğŸ“ è®°å½•å•è¯è¿›åº¦: ${word} - ${progress.success ? 'æˆåŠŸ' : 'å¤±è´¥'}`)
      return true
    } catch (error) {
      console.error('è®°å½•å•è¯è¿›åº¦å¤±è´¥:', error)
      return false
    }
  }

  /**
   * è®°å½•å•è¯é”™è¯¯æ‹¼å†™æ¬¡æ•°
   * @param {string} word - å•è¯
   * @param {Object} errorData - é”™è¯¯æ•°æ®
   * @returns {boolean} æ˜¯å¦æˆåŠŸ
   */
  recordWordError(word, errorData = {}) {
    try {
      const key = `word_errors_${word}`
      const existingData = util.storage.get(key) || {
        word,
        totalErrors: 0,
        errorHistory: [],
        firstErrorDate: null,
        lastErrorDate: null
      }
      
      // æ›´æ–°é”™è¯¯æ¬¡æ•°
      existingData.totalErrors += 1
      existingData.lastErrorDate = new Date().toISOString()
      
      if (!existingData.firstErrorDate) {
        existingData.firstErrorDate = existingData.lastErrorDate
      }
      
      // è®°å½•é”™è¯¯è¯¦æƒ…
      const errorRecord = {
        timestamp: new Date().toISOString(),
        sessionId: errorData.sessionId || '',
        errorType: errorData.errorType || 'spelling', // spelling, timeout, skip
        userInput: errorData.userInput || '',
        correctAnswer: word,
        attemptNumber: errorData.attemptNumber || 1
      }
      
      existingData.errorHistory.push(errorRecord)
      
      // ä¿æŒé”™è¯¯å†å²è®°å½•åœ¨åˆç†èŒƒå›´å†…ï¼ˆæœ€å¤šä¿ç•™50æ¡ï¼‰
      if (existingData.errorHistory.length > 50) {
        existingData.errorHistory = existingData.errorHistory.slice(-50)
      }
      
      util.storage.set(key, existingData)
      
      console.log(`âŒ è®°å½•å•è¯é”™è¯¯: ${word} - æ€»é”™è¯¯æ¬¡æ•°: ${existingData.totalErrors}`)
      return true
    } catch (error) {
      console.error('è®°å½•å•è¯é”™è¯¯å¤±è´¥:', error)
      return false
    }
  }

  /**
   * è·å–å•è¯é”™è¯¯ç»Ÿè®¡
   * @param {string} word - å•è¯
   * @returns {Object} é”™è¯¯ç»Ÿè®¡æ•°æ®
   */
  getWordErrorStats(word) {
    try {
      const key = `word_errors_${word}`
      const errorData = util.storage.get(key)
      
      if (!errorData) {
        return {
          word,
          totalErrors: 0,
          errorHistory: [],
          firstErrorDate: null,
          lastErrorDate: null
        }
      }
      
      return errorData
    } catch (error) {
      console.error('è·å–å•è¯é”™è¯¯ç»Ÿè®¡å¤±è´¥:', error)
      return {
        word,
        totalErrors: 0,
        errorHistory: [],
        firstErrorDate: null,
        lastErrorDate: null
      }
    }
  }

  /**
   * è·å–ç”¨æˆ·æœ€å®¹æ˜“å‡ºé”™çš„å•è¯æ’è¡Œæ¦œ
   * @param {number} limit - è¿”å›æ•°é‡é™åˆ¶ï¼Œé»˜è®¤10ä¸ª
   * @returns {Array} é”™è¯¯å•è¯æ’è¡Œæ¦œ
   */
  getMostErrorProneWords(limit = 10) {
    try {
      const allKeys = util.storage.getAllKeys()
      const errorKeys = allKeys.filter(key => key.startsWith('word_errors_'))
      
      const errorStats = errorKeys.map(key => {
        const data = util.storage.get(key)
        return {
          word: data.word,
          totalErrors: data.totalErrors,
          lastErrorDate: data.lastErrorDate,
          errorRate: this.calculateWordErrorRate(data.word)
        }
      })
      
      // æŒ‰é”™è¯¯æ¬¡æ•°é™åºæ’åº
      errorStats.sort((a, b) => b.totalErrors - a.totalErrors)
      
      return errorStats.slice(0, limit)
    } catch (error) {
      console.error('è·å–é”™è¯¯å•è¯æ’è¡Œæ¦œå¤±è´¥:', error)
      return []
    }
  }

  /**
   * è®¡ç®—å•è¯é”™è¯¯ç‡
   * @param {string} word - å•è¯
   * @returns {number} é”™è¯¯ç‡ï¼ˆ0-100ï¼‰
   */
  calculateWordErrorRate(word) {
    try {
      const errorData = this.getWordErrorStats(word)
      const progressKey = `word_progress_${word}`
      const progressData = util.storage.get(progressKey)
      
      if (!progressData && errorData.totalErrors === 0) {
        return 0
      }
      
      const totalAttempts = (progressData ? 1 : 0) + errorData.totalErrors
      const errorRate = totalAttempts > 0 ? (errorData.totalErrors / totalAttempts) * 100 : 0
      
      return Math.round(errorRate * 100) / 100 // ä¿ç•™ä¸¤ä½å°æ•°
    } catch (error) {
      console.error('è®¡ç®—å•è¯é”™è¯¯ç‡å¤±è´¥:', error)
      return 0
    }
  }

  /**
   * æ¸…é™¤å•è¯é”™è¯¯è®°å½•
   * @param {string} word - å•è¯ï¼Œå¦‚æœä¸æä¾›åˆ™æ¸…é™¤æ‰€æœ‰é”™è¯¯è®°å½•
   * @returns {boolean} æ˜¯å¦æˆåŠŸ
   */
  clearWordErrors(word = null) {
    try {
      if (word) {
        // æ¸…é™¤ç‰¹å®šå•è¯çš„é”™è¯¯è®°å½•
        const key = `word_errors_${word}`
        util.storage.remove(key)
        console.log(`ğŸ§¹ å·²æ¸…é™¤å•è¯ ${word} çš„é”™è¯¯è®°å½•`)
      } else {
        // æ¸…é™¤æ‰€æœ‰å•è¯é”™è¯¯è®°å½•
        const allKeys = util.storage.getAllKeys()
        const errorKeys = allKeys.filter(key => key.startsWith('word_errors_'))
        
        errorKeys.forEach(key => {
          util.storage.remove(key)
        })
        
        console.log(`ğŸ§¹ å·²æ¸…é™¤æ‰€æœ‰å•è¯é”™è¯¯è®°å½•ï¼Œå…± ${errorKeys.length} æ¡`)
      }
      
      return true
    } catch (error) {
      console.error('æ¸…é™¤å•è¯é”™è¯¯è®°å½•å¤±è´¥:', error)
      return false
    }
  }

  /**
   * ä¿å­˜å…³å¡ä¸­é€”è¿›åº¦
   * @param {number} levelId - å…³å¡ID
   * @param {Object} progressData - è¿›åº¦æ•°æ®
   * @returns {boolean} æ˜¯å¦æˆåŠŸ
   */
  saveLevelProgress(levelId, progressData) {
    try {
      const progressKey = `level_progress_${levelId}`
      const saveData = {
        levelId,
        currentWordIndex: progressData.currentWordIndex,
        stats: progressData.stats,
        sessionId: progressData.sessionId,
        savedAt: new Date().toISOString(),
        mode: progressData.mode || 'learn'
      }
      
      util.storage.set(progressKey, saveData)
      console.log(`ğŸ’¾ ä¿å­˜å…³å¡${levelId}ä¸­é€”è¿›åº¦: å•è¯ç´¢å¼•${progressData.currentWordIndex}`)
      return true
    } catch (error) {
      console.error('ä¿å­˜å…³å¡è¿›åº¦å¤±è´¥:', error)
      return false
    }
  }

  /**
   * è·å–å…³å¡ä¸­é€”è¿›åº¦
   * @param {number} levelId - å…³å¡ID
   * @returns {Object|null} è¿›åº¦æ•°æ®
   */
  getLevelProgress(levelId) {
    try {
      const progressKey = `level_progress_${levelId}`
      const progressData = util.storage.get(progressKey)
      
      if (progressData) {
        console.log(`ğŸ“– æ‰¾åˆ°å…³å¡${levelId}çš„ä¸­é€”è¿›åº¦: å•è¯ç´¢å¼•${progressData.currentWordIndex}`)
        return progressData
      }
      
      return null
    } catch (error) {
      console.error('è·å–å…³å¡è¿›åº¦å¤±è´¥:', error)
      return null
    }
  }

  /**
   * æ¸…é™¤å…³å¡ä¸­é€”è¿›åº¦
   * @param {number} levelId - å…³å¡ID
   * @returns {boolean} æ˜¯å¦æˆåŠŸ
   */
  clearLevelProgress(levelId) {
    try {
      const progressKey = `level_progress_${levelId}`
      util.storage.remove(progressKey)
      console.log(`ğŸ—‘ï¸ æ¸…é™¤å…³å¡${levelId}çš„ä¸­é€”è¿›åº¦`)
      return true
    } catch (error) {
      console.error('æ¸…é™¤å…³å¡è¿›åº¦å¤±è´¥:', error)
      return false
    }
  }

  /**
   * å®Œæˆå…³å¡å­¦ä¹ 
   * @param {number} levelId - å…³å¡ID
   * @param {Object} stats - ç»Ÿè®¡æ•°æ®
   * @returns {Promise<boolean>} æ˜¯å¦æˆåŠŸ
   */
  async completeLevelProgress(levelId, stats) {
    try {
      const levelKey = `level_complete_${levelId}`
      const levelData = {
        levelId,
        accuracy: stats.accuracy,
        totalWords: stats.totalWords,
        correctWords: stats.correctWords,
        sessionId: stats.sessionId,
        completedAt: new Date().toISOString()
      }
      
      util.storage.set(levelKey, levelData)
      
      // æ¸…é™¤ä¸­é€”è¿›åº¦
      this.clearLevelProgress(levelId)
      
      // è§£é”ä¸‹ä¸€å…³
      await this.unlockNextLevel(levelId)
      
      console.log(`ğŸ‰ å®Œæˆå…³å¡ ${levelId}: ${stats.correctWords}/${stats.totalWords} æ­£ç¡®`)
      return true
    } catch (error) {
      console.error('è®°å½•å…³å¡å®Œæˆå¤±è´¥:', error)
      return false
    }
  }

  /**
   * è§£é”ä¸‹ä¸€å…³
   * @param {number} currentLevel - å½“å‰å…³å¡
   * @returns {Promise<void>}
   */
  async unlockNextLevel(currentLevel) {
    try {
      console.log(`ğŸ” å¼€å§‹è§£é”å…³å¡${currentLevel + 1}...`)
      
      const userProfile = this.getUserProfile()
      console.log(`ğŸ“Š å½“å‰ç”¨æˆ·æ¡£æ¡ˆ: currentLevel=${userProfile.currentLevel}, progress.currentLevel=${userProfile.progress.currentLevel}`)
      console.log(`ğŸ“‹ å·²å®Œæˆå…³å¡: [${userProfile.progress.completedLevels.join(', ')}]`)
      
      if (userProfile && currentLevel >= userProfile.currentLevel) {
        // åŒæ—¶æ›´æ–°ä¸¤ä¸ªä½ç½®çš„currentLevelä»¥ç¡®ä¿å…¼å®¹æ€§
        const oldCurrentLevel = userProfile.currentLevel
        userProfile.currentLevel = currentLevel + 1
        userProfile.progress.currentLevel = currentLevel + 1
        
        console.log(`ğŸ“ˆ æ›´æ–°currentLevel: ${oldCurrentLevel} -> ${currentLevel + 1}`)
        
        // æ ‡è®°å½“å‰å…³å¡ä¸ºå·²å®Œæˆ
        if (!userProfile.progress.completedLevels.includes(currentLevel)) {
          userProfile.progress.completedLevels.push(currentLevel)
          console.log(`âœ… æ·»åŠ å·²å®Œæˆå…³å¡: ${currentLevel}`)
        } else {
          console.log(`â„¹ï¸ å…³å¡${currentLevel}å·²åœ¨å®Œæˆåˆ—è¡¨ä¸­`)
        }
        
        // ç­‰å¾…ä¿å­˜å®Œæˆ
        console.log(`ğŸ’¾ ä¿å­˜ç”¨æˆ·æ¡£æ¡ˆ...`)
        await this.saveUserProfile(userProfile)
        console.log(`ğŸ”“ è§£é”å…³å¡ ${currentLevel + 1}ï¼Œå·²å®Œæˆå…³å¡: [${userProfile.progress.completedLevels.join(', ')}]`)
      } else {
        console.log(`â­ï¸ è·³è¿‡è§£é”: currentLevel=${currentLevel}, userProfile.currentLevel=${userProfile.currentLevel}`)
      }
    } catch (error) {
      console.error('âŒ è§£é”ä¸‹ä¸€å…³å¤±è´¥:', error)
    }
  }

  /**
   * æ›´æ–°ç”¨æˆ·ç»Ÿè®¡
   * @param {boolean} success - æ˜¯å¦æˆåŠŸ
   */
  updateUserStats(success) {
    try {
      const userProfile = this.getUserProfile()
      if (userProfile) {
        if (success) {
          userProfile.totalWordsLearned = (userProfile.totalWordsLearned || 0) + 1
          userProfile.streak = (userProfile.streak || 0) + 1
        } else {
          userProfile.streak = 0
        }
        userProfile.lastStudyDate = new Date().toISOString()
        this.saveUserProfile(userProfile)
      }
    } catch (error) {
      console.error('æ›´æ–°ç”¨æˆ·ç»Ÿè®¡å¤±è´¥:', error)
    }
  }

  /**
   * æ ¼å¼åŒ–æ—¥æœŸ
   * @param {Date} date - æ—¥æœŸå¯¹è±¡
   * @param {string} format - æ ¼å¼
   * @returns {string} æ ¼å¼åŒ–åçš„æ—¥æœŸ
   */
  formatDate(date, format) {
    const year = date.getFullYear()
    const month = String(date.getMonth() + 1).padStart(2, '0')
    const day = String(date.getDate()).padStart(2, '0')
    
    return format.replace('YYYY', year).replace('MM', month).replace('DD', day)
  }
}

// åˆ›å»ºå…¨å±€å®ä¾‹
const dataManager = new DataManager()

module.exports = dataManager

---

**è¯´æ˜ï¼š**
## é…ç½®ç®¡ç†æ¨¡å— (utils/config.js)

```javascript
/**
 * é…ç½®ç®¡ç†æ¨¡å—
 * é›†ä¸­ç®¡ç†APIé…ç½®å’Œåº”ç”¨è®¾ç½®
 */

// ç¯å¢ƒé…ç½®
const ENV = {
  DEVELOPMENT: 'development',
  PRODUCTION: 'production'
}

// å½“å‰ç¯å¢ƒï¼ˆå¼€å‘æ—¶å¯æ‰‹åŠ¨åˆ‡æ¢ï¼‰
const CURRENT_ENV = ENV.DEVELOPMENT

// APIåŸºç¡€é…ç½®
const API_CONFIG = {
  
  // AIæœåŠ¡é…ç½®
  ai: {
    qwenplus: {
      enabled: true,
      // ç”Ÿäº§ç¯å¢ƒåº”ä½¿ç”¨åç«¯ä»£ç†æˆ–ç¯å¢ƒå˜é‡
      apiKey: CURRENT_ENV === ENV.DEVELOPMENT ? 
        "sk-d8fa10db341a41f189d582a7486841c7" : 
        null,
      baseUrl: CURRENT_ENV === ENV.DEVELOPMENT ?
        "https://dashscope.aliyuncs.com/compatible-mode/v1/chat/completions" :
        "/api/ai/qwenplus",
      model: "qwen-plus",
      timeout: 15000,
      retryTimes: 2
    },
    
    // TTSè¯­éŸ³åˆæˆé…ç½®
    tts: {
      enabled: true,
      apiKey: CURRENT_ENV === ENV.DEVELOPMENT ? 
        "sk-d8fa10db341a41f189d582a7486841c7" : 
        null,
      baseUrl: CURRENT_ENV === ENV.DEVELOPMENT ?
        "https://dashscope.aliyuncs.com/api/v1/services/aigc/multimodal-generation" :
        "/api/ai/tts",
      model: "qwen-tts",
      timeout: 10000,
      retryTimes: 1,
      voice: "samantha", // é»˜è®¤è‹±æ–‡å¥³å£°
      format: "wav",
      speed: 1.0,
      volume: 1.0
    }
  },
  
}

// ç¼“å­˜é…ç½®
const CACHE_CONFIG = {
  
  // AIè®²è§£ç¼“å­˜
  ai: {
    storage: {
      enabled: true,
      maxAge: 30 * 24 * 60 * 60 * 1000, // 30å¤©è¿‡æœŸ
      keyPrefix: 'spellwell_ai_'
    }
  },
  
  // éŸ³é¢‘ç¼“å­˜é…ç½®
  audio: {
    storage: {
      enabled: true,
      maxAge: 20 * 60 * 60 * 1000, // 20å°æ—¶è¿‡æœŸï¼ˆé˜¿é‡Œäº‘URLæœ‰æ•ˆæœŸ24å°æ—¶ï¼‰
      maxCacheSize: 50, // æœ€å¤§ç¼“å­˜50ä¸ªéŸ³é¢‘æ–‡ä»¶
      keyPrefix: 'spellwell_audio_'
    },
    memory: {
      enabled: true,
      maxSize: 50, // å†…å­˜ç¼“å­˜æœ€å¤§50ä¸ªé¡¹ç›®
      maxAge: 20 * 60 * 60 * 1000 // 20å°æ—¶è¿‡æœŸ
    },
    preload: {
      enabled: true,
      maxPreloadWords: 5, // æœ€å¤šé¢„åŠ è½½5ä¸ªå•è¯çš„å‘éŸ³
      preloadOnLevelStart: true
    }
  },
  
  // ç”¨æˆ·æ•°æ®ç¼“å­˜
  user: {
    storage: {
      enabled: true,
      syncInterval: 5 * 60 * 1000, // 5åˆ†é’ŸåŒæ­¥ä¸€æ¬¡
      keyPrefix: 'spellwell_user_'
    }
  }
}

// åº”ç”¨é…ç½®
const APP_CONFIG = {
  // æ€§èƒ½é…ç½®
  performance: {
    // å†…å­˜ç®¡ç†
    memory: {
      autoCleanup: true,
      cleanupInterval: 10 * 60 * 1000, // 10åˆ†é’Ÿæ¸…ç†ä¸€æ¬¡
      maxCanvasInstances: 3
    }
  },
  
  // ç”¨æˆ·ä½“éªŒé…ç½®
  ux: {
    // åŠ è½½çŠ¶æ€
    loading: {
      minShowTime: 500, // æœ€å°æ˜¾ç¤ºæ—¶é—´ï¼Œé¿å…é—ªçƒ
      timeout: 30000 // è¶…æ—¶æ—¶é—´
    },
    
    // åé¦ˆé…ç½®
    feedback: {
      vibration: {
        enabled: true,
        patterns: {
          success: 'light',
          error: 'medium',
          warning: 'light'
        }
      },
    }
  },
  
  // å­¦ä¹ é…ç½®
  learning: {
    // ç®€åŒ–çš„å­¦ä¹ é…ç½®
    progress: {
      autoSave: true,
      saveInterval: 30 * 1000 // 30ç§’è‡ªåŠ¨ä¿å­˜
    }
  }
}

// å®‰å…¨é…ç½®
const SECURITY_CONFIG = {
  // APIå®‰å…¨
  api: {
    // è¯·æ±‚é™åˆ¶
    rateLimit: {
      ai: {
        requests: 50,         // æ¯å°æ—¶50æ¬¡
        window: 60 * 60 * 1000
      }
    },
    
    // è¯·æ±‚éªŒè¯
    validation: {
      enabled: true,
      maxRequestSize: 1024 * 1024, // 1MB
      allowedOrigins: CURRENT_ENV === ENV.DEVELOPMENT ? 
        ['*'] : 
        ['https://your-domain.com']
    }
  },
  
  // æ•°æ®å®‰å…¨
  data: {
    encryption: {
      enabled: CURRENT_ENV === ENV.PRODUCTION,
      algorithm: 'AES-256-GCM'
    },
    sanitization: {
      enabled: true,
      strictMode: CURRENT_ENV === ENV.PRODUCTION
    }
  }
}

/**
 * è·å–ç¯å¢ƒé…ç½®
 */
function getEnvConfig() {
  return {
    current: CURRENT_ENV,
    isDevelopment: CURRENT_ENV === ENV.DEVELOPMENT,
    isProduction: CURRENT_ENV === ENV.PRODUCTION
  }
}

/**
 * è·å–APIé…ç½®
 * @param {string} service æœåŠ¡åç§°
 * @returns {Object} APIé…ç½®
 */
function getApiConfig(service) {
  const config = API_CONFIG[service]
  if (!config) {
    console.warn(`APIé…ç½®ä¸å­˜åœ¨: ${service}`)
    return null
  }
  
  // å®‰å…¨æ£€æŸ¥ï¼šç”Ÿäº§ç¯å¢ƒä¸åº”åŒ…å«æ•æ„Ÿä¿¡æ¯
  if (CURRENT_ENV === ENV.PRODUCTION) {
    const secureConfig = { ...config }
    Object.keys(secureConfig).forEach(key => {
      if (secureConfig[key] && typeof secureConfig[key] === 'object') {
        if (secureConfig[key].apiKey || secureConfig[key].secretKey) {
          console.warn(`ç”Ÿäº§ç¯å¢ƒæ£€æµ‹åˆ°æ˜æ–‡APIå¯†é’¥: ${service}.${key}`)
        }
      }
    })
  }
  
  return config
}

/**
 * è·å–ç¼“å­˜é…ç½®
 * @param {string} type ç¼“å­˜ç±»å‹
 * @returns {Object} ç¼“å­˜é…ç½®
 */
function getCacheConfig(type) {
  return CACHE_CONFIG[type] || {}
}

/**
 * è·å–åº”ç”¨é…ç½®
 * @param {string} section é…ç½®èŠ‚
 * @returns {Object} åº”ç”¨é…ç½®
 */
function getAppConfig(section) {
  return section ? APP_CONFIG[section] : APP_CONFIG
}

/**
 * è·å–å®‰å…¨é…ç½®
 * @returns {Object} å®‰å…¨é…ç½®
 */
function getSecurityConfig() {
  return SECURITY_CONFIG
}

/**
 * éªŒè¯é…ç½®å®Œæ•´æ€§
 */
function validateConfig() {
  const issues = []
  
  // æ£€æŸ¥ç”Ÿäº§ç¯å¢ƒé…ç½®
  if (CURRENT_ENV === ENV.PRODUCTION) {
    // æ£€æŸ¥APIå¯†é’¥
    if (API_CONFIG.ai && API_CONFIG.ai.qwenplus && API_CONFIG.ai.qwenplus.apiKey) {
      issues.push('ç”Ÿäº§ç¯å¢ƒä¸åº”åœ¨å‰ç«¯åŒ…å«å®Œæ•´APIå¯†é’¥')
    }
    
    // æ£€æŸ¥å®‰å…¨é…ç½®
    if (!SECURITY_CONFIG.data.encryption.enabled) {
      issues.push('ç”Ÿäº§ç¯å¢ƒåº”å¯ç”¨æ•°æ®åŠ å¯†')
    }
  }
  
  // æ£€æŸ¥å¿…éœ€é…ç½®
  if (!API_CONFIG.ai || !API_CONFIG.ai.qwenplus) {
    issues.push('ç¼ºå°‘AIæœåŠ¡é…ç½®')
  }
  
  if (issues.length > 0) {
    console.warn('é…ç½®éªŒè¯å‘ç°é—®é¢˜:', issues)
  }
  
  return issues
}

module.exports = {
  ENV,
  getEnvConfig,
  getApiConfig,
  getCacheConfig,
  getAppConfig,
  getSecurityConfig,
  validateConfig,
  CURRENT_ENV,
  API_CONFIG,
  CACHE_CONFIG,
  APP_CONFIG,
  SECURITY_CONFIG
}
```

---

## æºä»£ç è¯´æ˜

- ä»¥ä¸Šä»£ç å±•ç¤ºäº†SpellWellè‹±è¯­å•è¯å­¦ä¹ å°ç¨‹åºçš„æ ¸å¿ƒåŠŸèƒ½å®ç°
- ä»£ç é‡‡ç”¨æ¨¡å—åŒ–è®¾è®¡ï¼ŒåŠŸèƒ½æ¸…æ™°ï¼Œä¾¿äºç»´æŠ¤å’Œæ‰©å±•
- ç¬¦åˆå¾®ä¿¡å°ç¨‹åºå¼€å‘è§„èŒƒï¼Œå…·æœ‰è‰¯å¥½çš„ç”¨æˆ·ä½“éªŒ
- ä»£ç æ€»é‡çº¦**48000è¡Œ**ï¼Œä½“ç°äº†è½¯ä»¶çš„å®Œæ•´æ€§å’Œå¤æ‚æ€§
- åŒ…å«ç»Ÿè®¡åˆ†æã€AIæ™ºèƒ½è®²è§£ã€æ•°æ®ç®¡ç†ã€éŸ³é¢‘æœåŠ¡ã€è¯åº“ç®¡ç†ã€ç¼“å­˜ç®¡ç†ã€å†’é™©åœ°å›¾ã€é…ç½®ç®¡ç†ç­‰æ ¸å¿ƒæ¨¡å—
- é‡‡ç”¨ES6+è¯­æ³•ï¼Œä»£ç ç»“æ„æ¸…æ™°ï¼Œæ³¨é‡Šå®Œæ•´
- é›†æˆäº†é˜¿é‡Œäº‘Qwen-Plus AIæœåŠ¡å’ŒTTSè¯­éŸ³åˆæˆæœåŠ¡
- å®ç°äº†å¤šå±‚ç¼“å­˜æœºåˆ¶ã€LRUç®—æ³•ä¼˜åŒ–ã€Canvasç»˜å›¾ç­‰å…ˆè¿›æŠ€æœ¯
- å±•ç¤ºäº†å®Œæ•´çš„å°ç¨‹åºå¼€å‘æŠ€æœ¯æ ˆå’Œæœ€ä½³å®è·µ